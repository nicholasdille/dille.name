{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop: GitLab CI","text":"<p>This site contains the exercises to learn about GitLab CI.</p>"},{"location":"#audience","title":"Audience","text":"<p>Software developers and system administrators who want to learn how to use GitLab CI.</p>"},{"location":"#duration","title":"Duration","text":"<p>Two days</p>"},{"location":"#expected-knowledge","title":"Expected knowledge","text":"<p>Basic under standing of another CI/CD server, e.g. GitHub and Jenkins</p>"},{"location":"#goals","title":"Goals","text":"<p>Learn about the features of GitLab CI and how to use then in a software development project.</p>"},{"location":"#style","title":"Style","text":"<p>20% theoretical introduction</p> <p>80% practical exercises</p> <p>The instructor will provide an introduction to each topic. Participants will then work on exercises. The instructor will be available to answer questions and provide hints. The instructor will also demonstrate solutions to the exercises.</p>"},{"location":"navigation/","title":"Navigation","text":"<p>All pages have the same navigation structure.</p>"},{"location":"navigation/#section-1-menu-on-the-left","title":"Section 1: Menu on the left","text":"<p>The left-hand menu contains the available chapters and displays the structure of the workshop.</p> <p>On smaller screens or windows, the left-hand menu can be shown by clicking on the burger menu .</p>"},{"location":"navigation/#section-2-page-contents-on-the-right","title":"Section 2: Page contents on the right","text":"<p>The right-hand menu contains the contents of the current chapter and lists all exercises contained in the current chapter.</p> <p>On smaller screens or windows, the right-hand menu can be shown by clicking on the burger menu  and then clicking on the icon  next to the current chapter.</p>"},{"location":"you_are_ready/","title":"You are ready!","text":"<p>A few last words...</p>"},{"location":"you_are_ready/#exercises-tell-a-story","title":"Exercises tell a story","text":"<p>Each chapter focuses on a single feature</p> <p>Each exercise improves the previous state</p> <p>All exercises will have leave some questions unanswered</p> <p>Following exercises will again improve</p>"},{"location":"you_are_ready/#work-at-your-own-pace","title":"Work at your own pace","text":"<p>Either follow topics and exercises at the instructor's pace</p> <p>Or work ahead if you finish early</p> <p>Please be mindful of other participants</p> <p>Please do not confuse participants with your questions when racing ahead</p>"},{"location":"000_rollout/exercise_gitlab/","title":"GitLab","text":"<p>This workshop is performed on a shared GitLab instance. You have been assigned a user and password for this instance in an email.</p>"},{"location":"000_rollout/exercise_gitlab/#task-1-retrieve-your-credentials-digitally","title":"Task 1: Retrieve your credentials digitally","text":"<p>You have received your credentials in an email but the password is not fun to type in. Let's retrieve it digitally:</p> <ol> <li>Go to https://code.inmylab.de</li> <li>Select your username from the list</li> <li>Login using your personal user <code>seatN</code> (where <code>N</code> is a number) and your code (looks like this <code>ABCDEF</code>)</li> <li>The web page displays your credentials</li> </ol> <p>Keep the page open to refer to your credentials anytime throughout the workshop.</p>"},{"location":"000_rollout/exercise_gitlab/#task-2-login-to-gitlab","title":"Task 2: Login to GitLab","text":"<p>Go to https://gitlab.inmylab.de and login with your credentials.</p> Hint (Click if you are stuck) <p>Your username looks like <code>seatN</code> where <code>N</code> is a number.</p> <p>Your password is a long, random string which is displayed on the web pages access in the previous task.</p>"},{"location":"000_rollout/exercise_gitlab/#task-3-access-the-demo-project","title":"Task 3: Access the demo project","text":"<p>A personal project has been provisioned for you to follow this workshop. It is called <code>demo</code>. Let's find it!</p> Hint (Click if you are stuck) <p>Personal projects are access by clicking on your avatar in the top left corner.</p> Solution (Click if you are stuck) <p>The deep link is https://gitlab.inmylab.de/seatN/demo where <code>N</code> is a number.</p>"},{"location":"000_rollout/exercise_ide/","title":"IDE","text":"<p>You can follow this workshop in the IDE (Integrated Development Environment) of your choice but...</p> <p>A web-based instance of Visual Studio Code has been provisioned for you to follow this workshop.</p>"},{"location":"000_rollout/exercise_ide/#task-access-your-instance-of-visual-studio-code","title":"Task: Access your instance of Visual Studio Code","text":"<ol> <li>Go to https://seatN.vscode.inmylab.de where <code>N</code> is a number.</li> <li>Login using your personal user <code>seatN</code> (where <code>N</code> is a number) and your password</li> </ol> <p>The password is the same as your GitLab password.</p> Hint (Click if you are stuck) <p>Your username looks like <code>seatN</code> where <code>N</code> is a number.</p> <p>Your password is a long, random string which is displayed on the web pages access in the previous chapter.</p>"},{"location":"000_rollout/exercise_project/","title":"Project","text":""},{"location":"000_rollout/exercise_project/#task-1-view-the-demo-project","title":"Task 1: View the demo project","text":"<p>Your instance of Visual Studio Code is provisioned with your credentials to allow Git-over-HTTP to the GitLab instance as well as a clone of the <code>demo</code> project.</p> <ol> <li>In the directory tree</li> <li>Find the <code>demo</code> project under <code>/home/seat</code></li> </ol>"},{"location":"000_rollout/exercise_project/#task-2-pulling-from-the-upstream-repository","title":"Task 2: Pulling from the upstream repository","text":"<p>The local clone of the <code>demo</code> project is configured with a remote pointing to the location of the original project on GitHub. This is prepared in case the instructor needs to fix a demo. Let's test this safeguard:</p> <ol> <li>Open a terminal</li> <li>Change to the <code>demo</code> project directory</li> <li>List remotes: <code>git remote -v</code></li> <li>Pull from the upstream repository: <code>git pull upstream</code></li> </ol>"},{"location":"010_jobs_and_stages/exercise/","title":"Jobs and stages","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>create jobs</li> <li>organize them in stages</li> <li>understand when jobs in different stages are executed</li> </ul>"},{"location":"010_jobs_and_stages/exercise/#preparation","title":"Preparation","text":"<p>This workshop is based on an example hello world application written in Go. Get the code using the following command:</p> <pre><code>git checkout origin/160_gitlab_ci/example_app -- '*'\n</code></pre>"},{"location":"010_jobs_and_stages/exercise/#task-1-create-a-single-job","title":"Task 1: Create a single job","text":"<p>Add a pipeline to build the code using the following commands:</p> <pre><code>apk update\napk add go\ngo build -o hello .\n./hello\n</code></pre> <p>See the official documentation about jobs.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Add a file called <code>.gitlab-ci.yml</code> in the root of the project</li> <li>Add a job called <code>build</code></li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>build:\n  script:\n  - apk update\n  - apk add go\n  - go build -o hello .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout origin/160_gitlab_ci/010_jobs_and_stages/build -- '*'\n</code></pre>"},{"location":"010_jobs_and_stages/exercise/#task-2-add-a-stage","title":"Task 2: Add a stage","text":"<p>Modify the pipeline to consist of two stages called <code>check</code> and <code>build</code> where the <code>check</code> stage contains the following commands:</p> <pre><code>apk update\napk add go\ngo fmt .\ngo vet .\n</code></pre> <p>See the official documentation about stages.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Define two stages using <code>stages</code></li> <li>Add a job called <code>check</code> in the stage <code>check</code></li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - go build -o hello .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout origin/160_gitlab_ci/010_jobs_and_stages/lint -- '*'\n</code></pre>"},{"location":"010_jobs_and_stages/exercise/#task-3-add-parallel-jobs","title":"Task 3: Add parallel jobs","text":"<p>Split the job <code>check</code> so that one job called <code>lint</code> executes <code>go fmt .</code> and another job called <code>audit</code> executes <code>go vet .</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Both jobs <code>lint</code> and <code>audit</code> must be in the stage <code>check</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - go build -o hello .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout origin/160_gitlab_ci/010_jobs_and_stages/parallel -- '*'\n</code></pre>"},{"location":"020_variables/exercise/","title":"Variables","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>add local variable to your pipeline</li> <li>consume pre-defined variables</li> <li>add secrets in the UI</li> </ul>"},{"location":"020_variables/exercise/#task-1-create-a-job-variable","title":"Task 1: Create a job variable","text":"<p>This exercise requires an updates version of our hello world program:</p> <pre><code>git checkout origin/160_gitlab_ci/020_variables/inline -- main.go\n</code></pre> <p>Add a variable called <code>version</code> to the job called <code>build</code> and modify the build command as follows:</p> <pre><code>go build -o hello -ldflags \"-X main.Version=${version}\" .\n</code></pre> <p>See the official documentation about variables.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Use the <code>variable</code> keyword to define a variable inside the job called <code>build</code></li> <li>Replace the build command with the one provided above</li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  variables:\n    version: dev\n  script:\n  - apk update\n  - apk add go\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${version}\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/020_variables/inline -- '*'</p>"},{"location":"020_variables/exercise/#task-2-use-a-predefined-variable","title":"Task 2: Use a predefined variable","text":"<p>Read the official documentation about predefined variables and replace the job variable with the predefined variable <code>CI_COMMIT_REF_NAME</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Remove the <code>variable</code> keyword from the job called <code>build</code></li> <li>Replace the variable <code>${version}</code> with the predefined variable <code>${CI_COMMIT_REF_NAME}</code></li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME}\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/020_variables/predefined -- '*'</p>"},{"location":"020_variables/exercise/#task-3-add-a-ci-variable-in-the-ui","title":"Task 3: Add a CI variable in the UI","text":"<p>This exercise requires an updates version of our hello world application:</p> <pre><code>git checkout origin/160_gitlab_ci/020_variables/ci -- main.go\n</code></pre> <p>The application now also prints the name of the author which must be supplied during compilation as well.</p> <p>Read the official documentation about CI variables and extend the build command to provide <code>main.Author</code> through a CI variable called <code>AUTHOR</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint 1 (Click if you are stuck) <ol> <li>Go to <code>Settings</code> &gt; <code>CI/CD</code> &gt; <code>Variables</code></li> <li>Add a variable called <code>AUTHOR</code> with your name</li> </ol> Hint 2 (Click if you are stuck) <p>The <code>-ldflags</code> option needs to be extended with <code>-X 'main.Author=${AUTHOR}'</code></p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/020_variables/ci -- '*'</p>"},{"location":"030_script_blocks/exercise/","title":"Scriptblocks","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>Use <code>before_script</code> and <code>after_script</code></li> <li>Separate preparation and cleanup commands from core functionality</li> </ul>"},{"location":"030_script_blocks/exercise/#task-separate-script-blocks-into-preparation-and-main-task","title":"Task: Separate script blocks into preparation and main task","text":"<p>Commands are currently specified using the <code>script</code> directive. These commands consist of preparation, core functionality and (possibly) cleanup.</p> <p>To improve readability, move the preparation of the execution environment to a <code>before_script</code>. See the official documentation.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Move calls to <code>apk</code> to the <code>before_script</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  before_script:\n  - apk update\n  - apk add go\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  before_script:\n  - apk update\n  - apk add go\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  before_script:\n  - apk update\n  - apk add go\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/030_script_blocks -- '*'</p> <p>Cleanup commands can be move to <code>after_script</code> (official documentation) but we have no use for this in the current example.</p>"},{"location":"030_script_blocks/exercise/#bonus-1-when-after_script-is-executed","title":"Bonus 1: When <code>after_script</code> is executed","text":"<p>Add commands to all three script block <code>before_script</code>, <code>script</code> and <code>after_script</code>. Test two scenarios:</p> <ol> <li>The pipeline succeeds</li> <li>The pipeline failes</li> </ol> <p>What happens to the code in <code>after_script</code>?</p> Solution (Click to reveal) <p>Command in <code>after_script</code> are always executed even if the job fails.</p> <p>This can be very useful for cleaning up.</p>"},{"location":"030_script_blocks/exercise/#bonus-2-what-happens-to-environment-variables-in-script-blocks","title":"Bonus 2: What happens to environment variables in script blocks?","text":"<p>Define environment variables in all three script blocks and display them in the same and in the following script block.</p> <p>When are environment variables available?</p> Solution (Click to reveal) <p>Commands in <code>before_script</code> and <code>script</code> share a shell session. Environment variables are available throughout these script blocks.</p> <p>Commands in <code>after_script</code> are executed in a new shell session. Environment variables defined in <code>before_script</code> and <code>script</code> are gone.</p>"},{"location":"040_image/exercise/","title":"Images","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>specify which container image to use for a job</li> <li>tailor the execution environment to your needs</li> </ul>"},{"location":"040_image/exercise/#task-simplify-using-container-images","title":"Task: Simplify using container images","text":"<p>In the previous exampes, we called <code>apk</code> at the beginning of every job to install Go. This had to be repeated for every job because Go was not present. Choosing an image for a job using the <code>image</code> directive, time is saved by avoiding commands to install required tools. See the official documentation.</p> <p>Replace the calls to <code>apk</code> with the container image <code>golang:1.19.2</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ul> <li>Remove <code>before_script</code></li> <li>Add <code>image: golang:1.19.2</code> instead</li> </ul> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  image: golang:1.19.2\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  image: golang:1.19.2\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  image: golang:1.19.2\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/040_image -- '*'</p>"},{"location":"040_image/exercise/#bonus-test-different-images","title":"Bonus: Test different images","text":"<p>Add a job to your pipeline to test different container images. Check how different images offer specialized execution environments:</p> <ol> <li>Use <code>python:3</code> and test running <code>python --version</code></li> <li>Use <code>node</code> and test running <code>node --version</code></li> </ol>"},{"location":"050_defaults/exercise/","title":"Defaults","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>avoid repetition in jobs</li> <li>specify defaults are the top of your pipeline</li> </ul>"},{"location":"050_defaults/exercise/#task-dont-repeat-yourself","title":"Task: Don't repeat yourself","text":"<p>All jobs currently have a dedicated <code>image</code> directive. Using defaults, this repetition can be avoided. See the official documentation.</p> <p>Replace job specific <code>image</code> directives with the <code>default</code> directive.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Remove <code>image</code> from all build jobs</li> <li>Add <code>default</code> with the <code>image</code> directive at the top</li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/050_default -- '*'</p>"},{"location":"050_defaults/exercise/#bonus-1-override-defaults","title":"Bonus 1: Override defaults","text":"<p>Jobs can still choose to use an image different from the default:</p> <ol> <li>Add a new job</li> <li>Add an <code>image</code> directory to the new job</li> <li>Specify a different image</li> <li>Check out how the executation environment changes</li> </ol>"},{"location":"050_defaults/exercise/#bonus-2-default-values-for-variables","title":"Bonus 2: Default values for variables","text":"<p>See the official documentation for <code>default</code> as well as <code>variables</code> and check how they are related.</p> Solution (Click if you are stuck) <p>Global variables are not located under <code>default</code> but under the global <code>variables</code> keyword.</p>"},{"location":"060_artifacts/exercise/","title":"Artifacts","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>define artifacts</li> <li>consume artifacts</li> </ul>"},{"location":"060_artifacts/exercise/#task-1-pass-an-artifact-to-the-next-stage","title":"Task 1: Pass an artifact to the next stage","text":"<p>Artifacts are useful for splitting a task in separate job. Refer to the official documentation.</p> <p>Improve the pipeline by using artifacts:</p> <ol> <li>Create an artifact from the <code>hello</code> binary</li> <li>Create a new stage called <code>test</code> with a job called <code>test</code></li> <li>Call the <code>hello</code> binary as a smoke test</li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Example for creating an artifacts:</p> <pre><code>job_name:\n  script:\n  - echo foo &gt;file.txt\n  artifacts:\n    paths:\n    - file.txt\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout origin/160_gitlab_ci/060_artifact -- '*'</p>"},{"location":"060_artifacts/exercise/#bonus-1-define-from-which-jobs-to-receive-artifacts","title":"Bonus 1: Define from which jobs to receive artifacts","text":"<p>Usually, artifacts are received from all jobs in the previous stages. Decide from which jobs to receive artifacts using the <code>dependencies</code> keyword. See the official documentation.</p> <p>Modify the job <code>test</code> to consume artifacts only from the job <code>build</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  dependencies:\n  - build\n  script:\n  - ./hello\n</code></pre>"},{"location":"060_artifacts/exercise/#bonus-2-passing-environment-variables","title":"Bonus 2: Passing environment variables","text":"<p>In some situations, artifacts are to heavy-weight and passing a variable would be enough. Read the documentation for passing environment variables and implement this between two jobs of your choice.</p> <p>The following hint and solution are a working example.</p> Hint (Click if you are stuck) <p>Example for creating an artifact for environment variables:</p> <pre><code>job_name:\n  script:\n  - echo \"foo=bar\" &gt;build.env\n  artifacts:\n    reports:\n      dotenv: build.env\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  variables:\n    BINARY_NAME: hello\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o \"${BINARY_NAME}\" \\\n        .\n  - echo \"${BINARY_NAME}\" &gt;build.env\n  artifacts:\n    paths:\n    - hello\n    reports:\n      dotenv: build.env\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./${BINARY_NAME}\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"065_job_dependencies/exercise/","title":"Job dependencies","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>ignore stages</li> <li>start jobs as soon as dependencies are met</li> </ul>"},{"location":"065_job_dependencies/exercise/#task-start-a-job-early","title":"Task: Start a job early","text":"<p>Start the job <code>build</code> as soon as the job <code>audit</code> completes without waiting for other job of the stage <code>check</code> to finish. Check out the official documentation of <code>needs</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  needs:\n  - audit\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"065_job_dependencies/exercise/#bonus-start-a-job-late","title":"Bonus: Start a job late","text":"<p>If two jobs in the same stage should not be executed at the same time, the <code>needs</code> keyword can also delay a job until the dependencies are met. Modify the job <code>lint</code> so that it waits for the job <code>audit</code> to finish.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  needs:\n  - audit\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  needs:\n  - audit\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"070_schedules/exercise/","title":"Schedules","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>schedule a pipeline run</li> <li>use a schedule to execute a preconfigured pipeline</li> </ul>"},{"location":"070_schedules/exercise/#task-create-a-schedule","title":"Task: Create a schedule","text":"<p>Create a schedule to run a 5 minutes on the branch <code>main</code> in the correct timezone. See the official documentation for schedules.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p>"},{"location":"070_schedules/exercise/#bonus-start-a-schedule-manually","title":"Bonus: Start a schedule manually","text":"<p>Run the previously created schedule manually by clicking the play button . This come in handy if you need to run a pipeline with pre-configured variables.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p>"},{"location":"090_unit_tests/exercise/","title":"Unit tests","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>execute unit tests</li> <li>publish results in GitLab</li> </ul> <p>This exercise adds a unit test to the hello world application.</p>"},{"location":"090_unit_tests/exercise/#preparation","title":"Preparation","text":"<p>Let's update the code:</p> <pre><code>git checkout origin/160_gitlab_ci/090_unit_tests -- main_test.go go.mod go.sum\n</code></pre>"},{"location":"090_unit_tests/exercise/#task-publish-unit-test-results","title":"Task: Publish unit test results","text":"<p>The following commands execute unit tests and automatically convert the results to JUnit using gotestsum:</p> <pre><code>go install gotest.tools/gotestsum@latest\ngotestsum --junitfile report.xml\n</code></pre> <p>See the official documentation for special artifacts and specifically reports.</p> <p>Add a job <code>unit_test</code> to the stage <code>check</code> containing the above commands. The job needs to define a special artifact from the file <code>report.xml</code> so that GitLab recognizes it as as JUnit XML report.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run which shows the unit test results on the tab in the overview.</p> Hint (Click if you are stuck) <p>GitLab has published an example. The unit test report is published using a special type of artifact:</p> <pre><code>build:\n  stage: test\n  script: echo\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout origin/160_gitlab_ci/090_unit_tests -- '*'\n</code></pre>"},{"location":"100_environments/exercise/","title":"Environments","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>use environments to specify deployment targets</li> <li>select environments dynamically</li> </ul>"},{"location":"100_environments/exercise/#preparation","title":"Preparation","text":"<p>Create CI variables for use in the following exercises:</p> <ol> <li>Retrieve passwords for dev and live environments from the info page</li> <li>Create unprotected but masked CI variable <code>PASS</code> twice with scope <code>dev</code> and <code>live</code></li> <li>Create unprotected CI variable <code>SEAT_INDEX</code> with your seat number</li> </ol>"},{"location":"100_environments/exercise/#task-1-add-target-environment","title":"Task 1: Add target environment","text":"<p>Add a new stage <code>deploy</code> with a job called <code>deploy</code> and use the following commands to upload the binary to the dev environment:</p> <pre><code>curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n    --fail \\\n    --verbose \\\n    --upload-file hello \\\n    --user seat:${PASS}\n</code></pre> <p>Mind that <code>curl</code> is not available in the default image <code>golang:1.19.2</code> but must be installed using the following commands. Apply what you learned about script blocks as well as separating commands into preparation, core steps and cleanup.</p> <pre><code>apt-get update\napt-get -y install curl ca-certificates\n</code></pre> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to download the <code>hello</code> binary from <code>https://seatN.dev.webdav.inmylab.de/hello</code>.</p> Hint (Click if you are stuck) <p>Install <code>curl</code> in a <code>before_script</code> to separate the preparation from the core steps:</p> <pre><code>job_name:\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n</code></pre> <p>Now place the <code>curl</code> command under <code>script</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n</code></pre>"},{"location":"100_environments/exercise/#task-2-add-deployment-to-development-environment","title":"Task 2: Add deployment to development environment","text":"<p>Create a new branch <code>dev</code> from the branch <code>main</code> and modify the job <code>deploy</code> to use the environment from the pre-defined variable <code>$CI_COMMIT_REF_NAME</code>. Mind that the upload URL is also using a hard-coded environment name.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <pre><code>stages:\n- check\n- build\n- test\n- deploy\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://${CI_COMMIT_REF_NAME}.seat${SEAT_INDEX}.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n</code></pre> <p>This was just a demonstration. The changes will not be preseved in the following chapters.</p>"},{"location":"100_environments/exercise/#task-3-add-deployment-to-production-environment","title":"Task 3: Add deployment to production environment","text":"<p>Create the branch <code>live</code> from the branch <code>dev</code> and push it without further changes.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to download the <code>hello</code> binary from <code>https://seatN.live.inmylab.de/hello</code>.</p> <p>Heads up</p> <p>Checkout the branch <code>main</code> to make sure that the following exercises are based on the correct code base.</p>"},{"location":"110_triggers/exercise/","title":"Triggers","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul> <p>Heads up</p> <p>Checkout the branch <code>main</code> to make sure that the following exercises are based on the correct code base.</p>"},{"location":"110_triggers/exercise/#preparation","title":"Preparation","text":"<p>Triggering another pipeline requires a seconds project:</p> <ol> <li>Create a new project (anywhere!)</li> <li>Add <code>.gitlab-ci.yml</code> with the following content to the root of new project:     <pre><code>test:\n  script:\n  - printenv\n</code></pre></li> </ol>"},{"location":"110_triggers/exercise/#task-1-using-a-trigger-token","title":"Task 1: Using a trigger token","text":"<p>The trigger token allows pipelines to be triggered using the API. Let's give this a try!</p> <p>In the web UI:</p> <ol> <li>In the second project, go to Settings &gt; CI/CD and unfold Pipeline trigger tokens</li> <li>Create a trigger token and copy the token as well as the <code>curl</code> snippet</li> <li>Go back to <code>demo</code> project</li> <li>Create an unprotected but masked CI variable called <code>TOKEN</code></li> </ol> <p>In your pipeline:</p> <ol> <li>Add new stage <code>trigger</code> as well as a job <code>trigger</code></li> <li>Add <code>curl</code> snippet in <code>script</code> block</li> <li>Replace <code>TOKEN</code> with the variable <code>$TOKEN</code></li> <li>Replace <code>REF_NAME</code> with branch name (<code>main</code>)</li> </ol> <p>Afterwards check the pipeline in both projects in the GitLab UI. You should see successful pipeline runs.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\ntrigger:\n  stage: trigger\n  script:\n  - |\n    curl -X POST \\\n        --fail \\\n        -F token=$TOKEN \\\n        -F ref=main \\\n        https://gitlab.inmylab.de/api/v4/projects/9999/trigger/pipeline\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"110_triggers/exercise/#task-2-using-a-multi-project-pipeline","title":"Task 2: Using a multi-project pipeline","text":"<p>The second option for triggering a pipeline in another project, are multi-project pipelines. They come with a handy syntax in <code>gitlab-ci.yaml</code> by using the <code>trigger</code> keyword.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to expand the downstream pipeline to see the jobs and their status.</p> Hint (Click if you are stuck) <p>Replace the <code>script</code> keyword with the <code>trigger</code> keyword.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger: &lt;path-to-project&gt;\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"110_triggers/exercise/#task-3-using-a-parent-child-pipeline","title":"Task 3: Using a parent-child pipeline","text":"<p>A parent-child pipeline executes a downstream pipeline from a YAML file. Modify the contents of the <code>trigger</code> keyword to use <code>include</code> to execute a pipeline with the same content as in the first task.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to expand the downstream pipeline to see the jobs and their status.</p> Hint (Click if you are stuck) <p>Create the file <code>child.yaml</code> with the following pipeline:</p> <pre><code>test:\n  script:\n  - printenv\n</code></pre> <p>Use <code>trigger</code> &gt; <code>include</code> to call the pipeline from this file.</p> Solution (Click if you are stuck) <p><code>child.yaml</code>:</p> <pre><code>test:\n  script:\n  - printenv\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre>"},{"location":"120_templates/exercise/","title":"Templates","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>create templates</li> <li>make jobs reusable</li> <li>load templates from different locations</li> </ul>"},{"location":"120_templates/exercise/#task-1-create-a-template-inline","title":"Task 1: Create a template inline","text":"<p>Create a template for compiling a go binary from the job <code>build</code> and use it in the job <code>build</code>. See the official documentation for templates for guidance.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> <pre><code>.build-go:\n  script:\n  #...\n\nbuild:\n  extends: #...\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\n.build-go:\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>You decide whether <code>artifacts</code> is part of the template or not!</p>"},{"location":"120_templates/exercise/#task-2-loading-templates-from-a-local-file","title":"Task 2: Loading templates from a local file","text":"<p>Move the template into a separate file <code>go.yaml</code> and use the <code>include</code> keyword to import the template.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.build-go:\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n</code></pre> Solution (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.build-go:\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>include:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre>"},{"location":"120_templates/exercise/#task-3-loading-templates-from-another-project","title":"Task 3: Loading templates from another project","text":"<p>Create a new project anywhere (!), move <code>go.yaml</code> there and fix the <code>include</code> keyword. See the extended syntax of the <code>include</code> keyword to import templates from another project.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>include:\n- project: seat/template-go\n  ref: main\n  file: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"130_rules/exercise/","title":"Rules","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>define when to run jobs (and when not)</li> <li>how (workflow) rules can apply to whole pipelines</li> <li>how to use GitLab Pages to publish static web pages</li> </ul> <p>In this exercise we will publish a static web page to download the <code>hello</code> binary.</p>"},{"location":"130_rules/exercise/#preparation","title":"Preparation","text":"<p>Add a file <code>public/index.html</code> to your project using the following command:</p> <pre><code>git checkout origin/160_gitlab_ci/130_rules -- 'public/index.html'\n</code></pre>"},{"location":"130_rules/exercise/#task-1-prevent-a-job-from-running","title":"Task 1: Prevent a job from running","text":"<p>Add a job <code>pages</code> to the stage <code>deploy</code> with the following content:</p> <pre><code>pages:\n  stage: deploy\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n</code></pre> <p>Review the official documentation for the <code>rules</code> keyword to limit the job <code>pages</code> to run when...</p> <ul> <li>the pipeline wastriggered by a push event</li> <li>the change applied to the default branch</li> </ul> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint 1 (Click if you are stuck) <p>In pre-defined variables see <code>$CI_PIPELINE_SOURCE</code> for trigger events, <code>$CI_COMMIT_REF_NAME</code> for the current Git reference and <code>$CI_DEFAULT_BRANCH</code> for the default branch.</p> Hint 2 (Click if you are stuck) <p>See complex rules for combining conditions using and (<code>&amp;&amp;</code>) and or (<code>||</code>).</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>include:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre>"},{"location":"130_rules/exercise/#task-2-prevent-a-pipeline-from-running","title":"Task 2: Prevent a pipeline from running","text":"<p>Rules can also be placed under the global <code>workflow</code> keyword to apply to the whole pipeline instead of individual jobs.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>The syntax of <code>workflow</code> looks like this:</p> <pre><code>workflow:\n  rules:\n  #...\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"130_rules/exercise/#task-3-use-deploy-freeze","title":"Task 3: Use deploy freeze","text":"<p>Projects can define a deploy freeze to prevent pipelines to run but the settings only results in an environment varialbe <code>$CI_DEPLOY_FREEZE</code>. Rules as well as workflow rules can be used to enforce deploy freezes.</p> <p>Modify the pipeline to prevent the execution when <code>$CI_DEPLOY_FREEZE</code> is not empty.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint 1 (Click if you are stuck) <p>Simply enter the variable into a rule to check if it is not empty.</p> Hint 2 (Click if you are stuck) <p>Checkout the <code>when</code> keyword under <code>if</code> to control whether to start a pipeline/job or not.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"140_merge_requests/exercise/","title":"Merge requests","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"140_merge_requests/exercise/#task-1-use-rules-to-run-in-merge-request-context","title":"Task 1: Use rules to run in merge request context","text":"<p>XXX run on push to main and MR: <code>lint</code>, <code>audit</code>, <code>unit_tests</code>, <code>build</code>, <code>test</code></p> <p>XXX run only on push to main: <code>trigger</code></p> <p>XXX keep rules on <code>pages</code></p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  trigger:\n    include: child.yaml\n</code></pre>"},{"location":"140_merge_requests/exercise/#task-2-avoid-repetition-using-rule-templates","title":"Task 2: Avoid repetition using rule templates","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre>"},{"location":"150_matrix_jobs/exercise/","title":"Matrix Jobs","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"150_matrix_jobs/exercise/#task-build-binary-for-multiple-platforms","title":"Task: Build binary for multiple platforms","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.build-go:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello-${GOOS}-${GOARCH} \\\n        .\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.19.2\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello-*\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  image: alpine\n  script:\n  - ./hello-linux-amd64\n\ndeploy:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  environment:\n    name: dev\n  before_script:\n  - apt-get update\n  - apt-get -y install curl ca-certificates\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre>"},{"location":"210_caches/exercise/","title":"Caches","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"210_caches/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"},{"location":"220_services/exercise/","title":"Services","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"220_services/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"},{"location":"230_docker/exercise/","title":"Docker","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"230_docker/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"},{"location":"240_registries/exercise/","title":"Registries","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"240_registries/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"},{"location":"250_releases/exercise/","title":"Releases","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"250_releases/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"},{"location":"270_renovate/exercise/","title":"Renovate","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"270_renovate/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"},{"location":"280_security/exercise/","title":"Security","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>XXX</li> </ul>"},{"location":"280_security/exercise/#task-1-xxx","title":"Task 1: XXX","text":"<p>XXX</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>XXX</p> Solution (Click if you are stuck) <p>XXX</p>"}]}