{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop: GitLab CI","text":"<p>This site contains the exercises to learn about GitLab CI.</p>"},{"location":"#audience","title":"Audience","text":"<p>Software developers and system administrators who want to learn how to use GitLab CI.</p>"},{"location":"#duration","title":"Duration","text":"<p>Two days</p>"},{"location":"#expected-knowledge","title":"Expected knowledge","text":"<p>Basic understanding of another CI/CD server, e.g. GitHub and Jenkins</p> <p>Basic understanding of bash</p>"},{"location":"#goals","title":"Goals","text":"<p>Learn about the features of GitLab CI and how to use then in a software development project.</p>"},{"location":"#style","title":"Style","text":"<p>20% theoretical introduction</p> <p>80% practical exercises</p> <p>The instructor will provide an introduction to each topic. Participants will then work on exercises. The instructor will be available to answer questions and provide hints. The instructor will also demonstrate solutions to the exercises.</p>"},{"location":"navigation/","title":"Navigation","text":"<p>All pages have the same navigation structure.</p>"},{"location":"navigation/#section-1-menu-on-the-left","title":"Section 1: Menu on the left","text":"<p>The left-hand menu contains the available chapters and displays the structure of the workshop.</p> <p>On smaller screens or windows, the left-hand menu can be shown by clicking on the burger menu .</p>"},{"location":"navigation/#section-2-page-contents-on-the-right","title":"Section 2: Page contents on the right","text":"<p>The right-hand menu contains the contents of the current chapter and lists all exercises contained in the current chapter.</p> <p>On smaller screens or windows, the right-hand menu can be shown by clicking on the burger menu  and then clicking on the icon  next to the current chapter.</p>"},{"location":"you_are_done/","title":"You are done!","text":""},{"location":"you_are_done/#congratulations","title":"Congratulations!","text":"<p>You have finished the workshop </p>"},{"location":"you_are_ready/","title":"You are ready!","text":"<p>A few last words...</p>"},{"location":"you_are_ready/#exercises-tell-a-story","title":"Exercises tell a story","text":"<p>Each chapter focuses on a single feature</p> <p>Each exercise improves the previous state</p> <p>All exercises will have leave some questions unanswered</p> <p>Following exercises will again improve</p>"},{"location":"you_are_ready/#work-at-your-own-pace","title":"Work at your own pace","text":"<p>Either follow topics and exercises at the instructor's pace</p> <p>Or work ahead if you finish early</p> <p>Please be mindful of other participants</p> <p>Please do not confuse participants with your questions when racing ahead</p>"},{"location":"you_are_ready/#dont-like-the-demo-env","title":"Don't like the demo env?","text":"<p>You can also use your own environment and IDE if you prefer. The following script prepares the checkout </p> <pre><code>#!/bin/bash\nset -o errexit\n\nread -p \"Please enter your seat number: \" SEAT_INDEX\nread -s -p \"Please enter your seat password: \" SEAT_PASS\n\necho \"https://seat${SEAT_INDEX}:${SEAT_PASS}@gitlab.inmylab.de\" &gt;\"${HOME}/.git-credentials.demo\"\n\nmkdir demo\npushd demo\n\ngit init --initial-branch=main\ngit config --local user.name \"${GIT_USER}\"\ngit config --local user.email \"${GIT_EMAIL}\"\ngit config --local credential.helper \"store --file=${HOME}/.git-credentials.demo\"\n\ngit remote add origin https://gitlab.inmylab.de/seat${SEAT_INDEX}/demo\ngit remote add upstream https://github.com/nicholasdille/container-slides\n\npopd\n</code></pre>"},{"location":"000_rollout/","title":"Rollout of 160_gitlab_ci","text":""},{"location":"000_rollout/#preparation","title":"Preparation","text":"<ol> <li>Set a timestamp for the event (<code>YYYY-mm-dd</code>)</li> <li>Update links from slides to exercises using regex <code>/hands-on/\\d{4}-\\d{2}-\\d{2}/</code></li> <li>Update syntax definitions for <code>Dockerfile</code> using regex: <code>docker/dockerfile:\\d+.\\d+.\\d+</code></li> <li>Update nginx using regex: <code>nginx:\\d+.\\d+.\\d+</code></li> <li>Update traefik using regex: <code>traefik:v\\d+.\\d+.\\d+</code></li> <li>Update GitLab using regex: <code>gitlab/gitlab-ce:\\d+.\\d+.\\d+-ce.0</code></li> <li>Update GitLab Runner using regex: <code>gitlab/gitlab-runner:v\\d+.\\d+.\\d+</code></li> <li>Update code-server using regex: <code>codercom/code-server:\\d+.\\d+.\\d+</code></li> <li>Update golang using regex: <code>golang:\\d+.\\d+.\\d+</code></li> <li>Update curl using regex: <code>curlimages/curl:\\d+.\\d+.\\d+</code></li> <li>Update docker using regex: <code>docker:\\d+.\\d+.\\d+(-dind)?</code> with replacement <code>docker:28.1.1$1</code></li> <li>Update ubuntu using regex: <code>ubuntu:\\d+.\\d+</code></li> <li>Update release-cli using regex: <code>registry.gitlab.com/gitlab-org/release-cli:v\\d+\\.\\d+\\.\\d+</code></li> <li>Update versions in <code>160_gitlab_ci/000_rollout/gitlab.pkr.hcl</code> for pre-pulling container images</li> </ol>"},{"location":"000_rollout/#prerequisites","title":"Prerequisites","text":"<pre><code>uniget install \\\n    packer \\\n    terraform \\\n    terraform-backend-git\n</code></pre>"},{"location":"000_rollout/#create-images","title":"Create images","text":"<pre><code>make uniget\nmake docker\nmake gitlab\n</code></pre>"},{"location":"000_rollout/#create-credentials-for-attendees","title":"Create credentials for attendees","text":"<pre><code>SET_NAME=20250512 COUNT=21 bash generate.sh\n</code></pre> <p>Store <code>seats.json</code> in a password manager</p>"},{"location":"000_rollout/#rollout-infrastructure","title":"Rollout infrastructure","text":"<p>Provide credentials for infrastructure</p> <pre><code>$ cat .env.mk\nHCLOUD_TOKEN := $(shell pp hcloud-web)\nHETZNERDNS_TOKEN := $(shell pp hetzner-dns-web)\nGIT_USERNAME := nicholasdille\nGIT_PASSWORD := $(shell pp github-terraform-state)\n</code></pre> <p>Make sure that <code>GIT_PASSWORD</code> is still valid for <code>https://github.com/nicholasdille/terraform-state</code>.</p> <p>Deploy infrastructure</p> <pre><code>make apply\n</code></pre> <p>Store the SSH config in a password manager</p>"},{"location":"000_rollout/#bootstrap-services","title":"Bootstrap services","text":"<p>Checkout the next directories called <code>../00?_*</code> and follow the instructions</p>"},{"location":"000_rollout/#check-containers","title":"Check containers","text":"<p>One-shot connection to remote Docker daemons:</p> <pre><code>docker -H ssh://gitlab ps\ndocker -H ssh://runner ps\ndocker -H ssh://vscode ps\n</code></pre> <p>Create Docker contexts:</p> <pre><code>docker context create gitlab --docker \"host=ssh://gitlab\"\ndocker context create runner --docker \"host=ssh://runner\"\ndocker context create vscode --docker \"host=ssh://vscode\"\n</code></pre> <p>Use contexts:</p> <pre><code>docker --context=gitlab ps\ndocker --context=runner ps\ndocker --context=vscode ps\n</code></pre>"},{"location":"000_rollout/#create-entries-in-password-manager","title":"Create entries in password manager","text":"<p>The following entries should be created:</p> <ul> <li><code>Code</code> for <code>https://code.inmylab.de</code></li> <li><code>GitLab</code> for <code>https://gitlab.inmylab.de</code> for user <code>root</code> and user <code>seat0</code></li> <li><code>GitLab PAT</code> for user <code>root</code> and user <code>seat0</code></li> <li><code>VSCode</code> for <code>https://vscode.inmylab.de</code> for user <code>seat0</code></li> <li><code>Grafana</code> for <code>https://grafana.inmylab.de</code> for user <code>admin</code> and GitLab root password</li> </ul>"},{"location":"000_rollout/#testing","title":"Testing","text":"<p>View GitLab:</p> <pre><code>ssh gitlab env -C /root/container-slides/160_gitlab_ci/001_server docker-compose ps -a\n</code></pre> <p>View GitLab Runner:</p> <pre><code>ssh gitlab env -C /root/container-slides/160_gitlab_ci/002_runner docker-compose ps -a\n</code></pre> <p>View instances of Visual Studio Code:</p> <pre><code>ssh vscode env -C /root/container-slides/160_gitlab_ci/003_vscode docker-compose ps -a --format \"table {{.ID}}\\t{{.Name}}\\t{{.State}}\"\n</code></pre> <p>Test DNS resolution:</p> <pre><code>dig +short code.inmylab.de\ndig +short gitlab.inmylab.de\ndig +short vscode.inmylab.de\ndig +short grafana.inmylab.de\n</code></pre> <p>Test endpoints:</p> <pre><code>curl -sSI https://code.inmylab.de/\ncurl -sSI https://gitlab.inmylab.de/\ncurl -sSI https://grafana.inmylab.de/\nseq 0 20 | xargs -I{} curl -sSI https://seat{}.vscode.inmylab.de\nseq 0 20 | xargs -I{} curl -sSI https://code.inmylab.de/seat{}/\n</code></pre> <p>List runners:</p> <pre><code>curl -sSLfH \"Private-Token: $(jq -r '.gitlab_admin_token' seats.json)\" https://gitlab.inmylab.de/api/v4/runners/all?type=instance_type | jq .\n</code></pre> <p>Test authentication for code.inmylab.de:</p> <pre><code>seq 0 20 \\\n| while read -r INDEX; do\n    CODE=\"$( jq -r --arg index ${INDEX} '.seats[$index | tonumber].code' seats.json )\"\n    AUTH=\"$( echo -n \"seat${INDEX}:${CODE}\" | base64 -w0 )\"\n    curl -sSIH \"Authorization: Basic ${AUTH}\" https://code.inmylab.de/seat${INDEX}/\ndone\n</code></pre> <p>Test authentication for vscode.inmylab.de:</p> <pre><code>seq 0 20 \\\n| while read -r INDEX; do\n    PASS=\"$( jq -r --arg index ${INDEX} '.seats[$index | tonumber].password' seats.json )\"\n    AUTH=\"$( echo -n \"seat${INDEX}:${PASS}\" | base64 -w0 )\"\n    curl -sSIH \"Authorization: Basic ${AUTH}\" https://seat${INDEX}.vscode.inmylab.de/\ndone\n</code></pre> <p>Test PAT for gitlab.inmylab.de:</p> <pre><code>seq 0 20 | while read -r INDEX; do\n    PAT=\"$( jq -r --arg index ${INDEX} '.[$index | tonumber]' ../001_server/personal_access_tokens.json )\"\n    curl -sSH \"Private-Token: ${PAT}\" https://gitlab.inmylab.de/api/v4/user \\\n    | jq -r .username\ndone\n</code></pre> <p>Block all users:</p> <pre><code>seq 0 20 | while read -r INDEX; do\n    PAT=\"$( jq -r '.gitlab_admin_token' seats.json )\"\n    USER_ID=\"$( curl -sSH \"Private-Token: ${PAT}\" https://gitlab.inmylab.de/api/v4/users?username=seat${INDEX} | jq -r .[0].id )\"\n    curl -sSH \"Private-Token: ${PAT}\" -X POST https://gitlab.inmylab.de/api/v4/users/${USER_ID}/block\ndone\n</code></pre> <p>Unblock all users:</p> <pre><code>seq 0 20 | while read -r INDEX; do\n    PAT=\"$( jq -r '.gitlab_admin_token' seats.json )\"\n    USER_ID=\"$( curl -sSH \"Private-Token: ${PAT}\" https://gitlab.inmylab.de/api/v4/users?username=seat${INDEX} | jq -r .[0].id )\"\n    curl -sSH \"Private-Token: ${PAT}\" -X POST https://gitlab.inmylab.de/api/v4/users/${USER_ID}/unblock\ndone\n</code></pre> <p>Fetch last activity:</p> <pre><code>seq 0 20 | while read -r INDEX; do\n    echo \"seat${INDEX}\"\n    PAT=\"$( jq -r '.gitlab_admin_token' seats.json )\"\n    USER_ID=\"$( curl -sSH \"Private-Token: ${PAT}\" https://gitlab.inmylab.de/api/v4/users?username=seat${INDEX} | jq -r .[0].id )\"\n    curl -sSH \"Private-Token: ${PAT}\" https://gitlab.inmylab.de/api/v4/users/${USER_ID} \\\n    | jq -r '\"  last_sign_in_at: \\(.last_sign_in_at)\\n  last_activity_on: \\(.last_activity_on)\\n  sign_in_count: \\(.sign_in_count)\"'\ndone\n</code></pre> <p>Test webdav:</p> <pre><code>seq 0 20 | while read -r INDEX; do\n    echo \"seat${INDEX}\"\n    PASS_DEV=\"$( jq -r --arg index ${INDEX} '.seats[$index | tonumber].webdav_pass_dev' seats.json )\"\n    curl -sSIu \"seat${INDEX}:${PASS_DEV}\" https://seat${INDEX}.dev.webdav.inmylab.de\n    PASS_LIVE=\"$( jq -r --arg index ${INDEX} '.seats[$index | tonumber].webdav_pass_live' seats.json )\"\n    curl -sSIu \"seat${INDEX}:${PASS_LIVE}\" https://seat${INDEX}.live.webdav.inmylab.de\ndone\n</code></pre>"},{"location":"000_rollout/exercise_gitlab/","title":"GitLab","text":"<p>This workshop is performed on a shared GitLab instance. You have been assigned a user and password for this instance in an email.</p>"},{"location":"000_rollout/exercise_gitlab/#task-1-retrieve-your-credentials-digitally","title":"Task 1: Retrieve your credentials digitally","text":"<p>You have received your credentials in an email but the password is not fun to type in. Let's retrieve it digitally:</p> <ol> <li>Go to https://code.inmylab.de</li> <li>Select your username from the list</li> <li>Login using your personal user <code>seatN</code> (where <code>N</code> is a number) and your code (looks like this <code>ABCDEF</code>)</li> <li>The web page displays your credentials</li> </ol> <p>Keep the page open to refer to your credentials anytime throughout the workshop.</p>"},{"location":"000_rollout/exercise_gitlab/#task-2-login-to-gitlab","title":"Task 2: Login to GitLab","text":"<p>Go to https://gitlab.inmylab.de and login with your credentials.</p> Hint (Click if you are stuck) <p>Your username looks like <code>seatN</code> where <code>N</code> is a number.</p> <p>Your password is a long, random string which is displayed on the web pages access in the previous task.</p>"},{"location":"000_rollout/exercise_gitlab/#task-3-access-the-demo-project","title":"Task 3: Access the demo project","text":"<p>A personal project has been provisioned for you to follow this workshop. It is called <code>demo</code>. Let's find it!</p> Hint (Click if you are stuck) <p>Personal projects are access by clicking on your avatar in the top left corner.</p> Solution (Click if you are stuck) <p>The deep link is https://gitlab.inmylab.de/seatN/demo where <code>N</code> is a number.</p>"},{"location":"000_rollout/exercise_ide/","title":"IDE","text":"<p>You can follow this workshop in the IDE (Integrated Development Environment) of your choice but...</p> <p>A web-based instance of Visual Studio Code has been provisioned for you to follow this workshop.</p> <p>Why not the integrated web IDE, you ask? Because it does not support a terminal for security reasons.</p>"},{"location":"000_rollout/exercise_ide/#task-1-access-your-instance-of-visual-studio-code","title":"Task 1: Access your instance of Visual Studio Code","text":"<ol> <li>Go to <code>https://seatN.vscode.inmylab.de</code> where <code>N</code> is a number.</li> <li>Login using your personal user <code>seatN</code> (where <code>N</code> is a number) and your password</li> </ol> <p>The password is the same as your GitLab password.</p> Hint (Click if you are stuck) <p>Your username looks like <code>seatN</code> where <code>N</code> is a number.</p> <p>Your password is a long, random string which is displayed on the web pages access in the previous chapter.</p>"},{"location":"000_rollout/exercise_ide/#task-2-use-git-in-visual-studio-code","title":"Task 2: Use git in Visual Studio Code","text":"<p>Familiarize yourself with Visual Studio Code and the git workflow:</p> <ol> <li>Make a small change to <code>README.md</code></li> <li>Stage the change</li> <li>Commit the change</li> <li>Push the commit</li> <li>Make sure the change is visible in GitLab</li> </ol> Hint (Click if you are stuck) <p>Check the official documentation of Visual Studio Code for help with the git workflow.</p> Hint (Click if you are stuck) <p>Make sure you enter a commit message - either in the box above the commit button or in the input box after you clicked the commit button.</p> Hint (Click if you are stuck) <p>Go to GitLab (<code>https://gitlab.inmylab.de</code>) and go to your project called <code>demo</code>.</p>"},{"location":"000_rollout/exercise_project/","title":"Project","text":""},{"location":"000_rollout/exercise_project/#task-1-view-the-demo-project","title":"Task 1: View the demo project","text":"<p>Your instance of Visual Studio Code is provisioned with your credentials to allow Git-over-HTTP to the GitLab instance as well as a clone of the <code>demo</code> project.</p> <ol> <li>In the directory tree</li> <li>Find the <code>demo</code> project under <code>/home/seat</code></li> </ol>"},{"location":"000_rollout/exercise_project/#task-2-pulling-from-the-upstream-repository","title":"Task 2: Pulling from the upstream repository","text":"<p>The local clone of the <code>demo</code> project is configured with a remote pointing to the location of the original project on GitHub. This is prepared in case the instructor needs to fix a demo. Let's test this safeguard:</p> <ol> <li>Open a terminal</li> <li>Change to the <code>demo</code> project directory</li> <li>List remotes: <code>git remote -v</code></li> <li>Pull from the upstream repository: <code>git pull upstream</code></li> </ol>"},{"location":"010_jobs_and_stages/exercise/","title":"Jobs and stages","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>create jobs</li> <li>organize them in stages</li> <li>understand when jobs in different stages are executed</li> </ul>"},{"location":"010_jobs_and_stages/exercise/#preparation","title":"Preparation","text":"<p>This workshop is based on an example hello world application written in Go. Get the code using the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/example_app -- '*'\n</code></pre>"},{"location":"010_jobs_and_stages/exercise/#task-1-create-a-single-job","title":"Task 1: Create a single job","text":"<p>Add a pipeline to build the code using the following commands:</p> <pre><code>apk update\napk add go\ngo build -o hello .\n./hello\n</code></pre> <p>See the official documentation about jobs.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Add a file called <code>.gitlab-ci.yml</code> in the root of the project</li> <li>Add a job called <code>build</code></li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>build:\n  script:\n  - apk update\n  - apk add go\n  - go build -o hello .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/010_jobs_and_stages/build -- '*'\n</code></pre>"},{"location":"010_jobs_and_stages/exercise/#task-2-add-a-stage","title":"Task 2: Add a stage","text":"<p>Modify the pipeline to consist of two stages called <code>check</code> and <code>build</code> where the <code>check</code> stage contains the following commands:</p> <pre><code>apk update\napk add go\ngo fmt .\ngo vet .\n</code></pre> <p>See the official documentation about stages.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Define two stages using <code>stages</code></li> <li>Add a job called <code>check</code> in the stage <code>check</code></li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - go build -o hello .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/010_jobs_and_stages/lint -- '*'\n</code></pre>"},{"location":"010_jobs_and_stages/exercise/#task-3-add-parallel-jobs","title":"Task 3: Add parallel jobs","text":"<p>Split the job <code>check</code> so that one job called <code>lint</code> executes <code>go fmt .</code> and another job called <code>audit</code> executes <code>go vet .</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Both jobs <code>lint</code> and <code>audit</code> must be in the stage <code>check</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - go build -o hello .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/010_jobs_and_stages/parallel -- '*'\n</code></pre>"},{"location":"020_variables/exercise/","title":"Variables","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>add local variable to your pipeline</li> <li>consume pre-defined variables</li> <li>add secrets in the UI</li> </ul>"},{"location":"020_variables/exercise/#preparation","title":"Preparation","text":"<p>This exercise requires an updated version of our hello world program:</p> <pre><code>git checkout upstream/160_gitlab_ci/020_variables/inline -- main.go\n</code></pre>"},{"location":"020_variables/exercise/#task-1-create-a-job-variable","title":"Task 1: Create a job variable","text":"<p>Add a variable called <code>version</code> to the job called <code>build</code> and modify the build command as follows:</p> <pre><code>go build -o hello -ldflags \"-X main.Version=${version}\" .\n</code></pre> <p>See the official documentation about variables.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Use the <code>variable</code> keyword to define a variable inside the job called <code>build</code></li> <li>Replace the build command with the one provided above</li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  variables:\n    version: dev\n  script:\n  - apk update\n  - apk add go\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${version}\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout upstream/160_gitlab_ci/020_variables/inline -- '*'</p>"},{"location":"020_variables/exercise/#task-2-use-a-predefined-variable","title":"Task 2: Use a predefined variable","text":"<p>Read the official documentation about predefined variables and replace the job variable with the predefined variable <code>CI_COMMIT_REF_NAME</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Remove the <code>variable</code> keyword from the job called <code>build</code></li> <li>Replace the variable <code>${version}</code> with the predefined variable <code>${CI_COMMIT_REF_NAME}</code></li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME}\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <p>git checkout upstream/160_gitlab_ci/020_variables/predefined -- '*'</p>"},{"location":"020_variables/exercise/#task-3-add-a-ci-variable-in-the-ui","title":"Task 3: Add a CI variable in the UI","text":"<p>This task requires an updated version of our hello world application:</p> <pre><code>git checkout upstream/160_gitlab_ci/020_variables/ci -- main.go\n</code></pre> <p>Also, update the build command to inject the author into the variable:</p> <pre><code>go build -o hello -ldflags \"-X main.Version=${version} -X 'main.Author=${AUTHOR}'\" .\n</code></pre> <p>The application now also prints the name of the author which must be supplied during compilation as well.</p> <p>Read the official documentation about CI variables and extend the build command to provide <code>main.Author</code> through a CI variable called <code>AUTHOR</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint 1 (Click if you are stuck) <ol> <li>Go to <code>Settings</code> &gt; <code>CI/CD</code> &gt; <code>Variables</code></li> <li>Add a variable called <code>AUTHOR</code> with your name</li> </ol> Hint 2 (Click if you are stuck) <p>The <code>-ldflags</code> option needs to be extended with <code>-X 'main.Author=${AUTHOR}'</code></p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - apk update\n  - apk add go\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - apk update\n  - apk add go\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/020_variables/ci -- '*'\n</code></pre>"},{"location":"030_script_blocks/exercise/","title":"Scriptblocks","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>Use <code>before_script</code> and <code>after_script</code></li> <li>Separate preparation and cleanup commands from core functionality</li> </ul>"},{"location":"030_script_blocks/exercise/#task-separate-script-blocks-into-preparation-and-main-task","title":"Task: Separate script blocks into preparation and main task","text":"<p>Commands are currently specified using the <code>script</code> directive. These commands consist of preparation, core functionality and (possibly) cleanup.</p> <p>To improve readability, move the preparation of the execution environment to a <code>before_script</code>. See the official documentation.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Move calls to <code>apk</code> to the <code>before_script</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  before_script:\n  - apk update\n  - apk add go\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  before_script:\n  - apk update\n  - apk add go\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  before_script:\n  - apk update\n  - apk add go\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/030_script_blocks -- '*'\n</code></pre> <p>Cleanup commands can be move to <code>after_script</code> (official documentation) but we have no use for this in the current example.</p>"},{"location":"030_script_blocks/exercise/#bonus-task-1-when-after_script-is-executed","title":"Bonus task 1: When <code>after_script</code> is executed","text":"<p>Add commands to all three script block <code>before_script</code>, <code>script</code> and <code>after_script</code>. Test two scenarios:</p> <ol> <li>The pipeline succeeds</li> <li>The pipeline failes</li> </ol> <p>What happens to the code in <code>after_script</code>?</p> Solution (Click to reveal) <p>Command in <code>after_script</code> are always executed even if the job fails.</p> <p>This can be very useful for cleaning up.</p>"},{"location":"030_script_blocks/exercise/#bonus-task-2-what-happens-to-environment-variables-in-script-blocks","title":"Bonus task 2: What happens to environment variables in script blocks?","text":"<p>Define environment variables in all three script blocks and display them in the same and in the following script block.</p> <p>When are environment variables available?</p> Solution (Click to reveal) <p>Commands in <code>before_script</code> and <code>script</code> share a shell session. Environment variables are available throughout these script blocks.</p> <p>Commands in <code>after_script</code> are executed in a new shell session. Environment variables defined in <code>before_script</code> and <code>script</code> are gone.</p>"},{"location":"040_image/exercise/","title":"Images","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>specify which container image to use for a job</li> <li>tailor the execution environment to your needs</li> </ul>"},{"location":"040_image/exercise/#task-simplify-using-container-images","title":"Task: Simplify using container images","text":"<p>In the previous exampes, we called <code>apk</code> at the beginning of every job to install Go. This had to be repeated for every job because Go was not present. Choosing an image for a job using the <code>image</code> directive, time is saved by avoiding commands to install required tools. See the official documentation.</p> <p>Replace the calls to <code>apk</code> with the container image <code>golang:1.24.3</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ul> <li>Remove <code>before_script</code></li> <li>Add <code>image: golang:1.24.3</code> instead</li> </ul> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\nlint:\n  stage: check\n  image: golang:1.24.3\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  image: golang:1.24.3\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  image: golang:1.24.3\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/040_image -- '*'\n</code></pre>"},{"location":"040_image/exercise/#bonus-task-test-different-images","title":"Bonus task: Test different images","text":"<p>Add a job to your pipeline to test different container images. Check how different images offer specialized execution environments:</p> <ol> <li>Use <code>python:3</code> and test running <code>python --version</code></li> <li>Use <code>node</code> and test running <code>node --version</code></li> </ol>"},{"location":"050_defaults/exercise/","title":"Defaults","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>avoid repetition in jobs</li> <li>specify defaults are the top of your pipeline</li> </ul>"},{"location":"050_defaults/exercise/#task-dont-repeat-yourself","title":"Task: Don't repeat yourself","text":"<p>All jobs currently have a dedicated <code>image</code> directive. Using defaults, this repetition can be avoided. See the official documentation.</p> <p>Replace job specific <code>image</code> directives with the <code>default</code> directive.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <ol> <li>Remove <code>image</code> from all build jobs</li> <li>Add <code>default</code> with the <code>image</code> directive at the top</li> </ol> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/050_default -- '*'\n</code></pre>"},{"location":"050_defaults/exercise/#bonus-task-1-override-defaults","title":"Bonus task 1: Override defaults","text":"<p>Jobs can still choose to use an image different from the default:</p> <ol> <li>Add a new job</li> <li>Add an <code>image</code> directory to the new job</li> <li>Specify a different image</li> <li>Check out how the executation environment changes</li> </ol>"},{"location":"050_defaults/exercise/#bonus-task-2-default-values-for-variables","title":"Bonus task 2: Default values for variables","text":"<p>See the official documentation for <code>default</code> as well as <code>variables</code> and check how they are related.</p> Solution (Click if you are stuck) <p>Global variables are not located under <code>default</code> but under the global <code>variables</code> keyword.</p>"},{"location":"060_artifacts/exercise/","title":"Artifacts","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>define artifacts</li> <li>consume artifacts</li> </ul>"},{"location":"060_artifacts/exercise/#task-pass-an-artifact-to-the-next-stage","title":"Task: Pass an artifact to the next stage","text":"<p>Artifacts are useful for splitting a task in separate job. Refer to the official documentation.</p> <p>Improve the pipeline by using artifacts:</p> <ol> <li>Create an artifact from the <code>hello</code> binary</li> <li>Create a new stage called <code>test</code> with a job called <code>test</code></li> <li>Call the <code>hello</code> binary as a smoke test</li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Example for creating an artifacts:</p> <pre><code>job_name:\n  script:\n  - echo foo &gt;file.txt\n  artifacts:\n    paths:\n    - file.txt\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/060_artifact -- '*'\n</code></pre>"},{"location":"060_artifacts/exercise/#bonus-task-1-define-from-which-jobs-to-receive-artifacts","title":"Bonus task 1: Define from which jobs to receive artifacts","text":"<p>Usually, artifacts are received from all jobs in the previous stages. Decide from which jobs to receive artifacts using the <code>dependencies</code> keyword. See the official documentation.</p> <p>Modify the job <code>test</code> to consume artifacts only from the job <code>build</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  dependencies:\n  - build\n  script:\n  - ./hello\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"060_artifacts/exercise/#bonus-task-2-passing-environment-variables","title":"Bonus task 2: Passing environment variables","text":"<p>In some situations, artifacts are to heavy-weight and passing a variable would be enough. Read the documentation for passing environment variables and implement this between two jobs of your choice.</p> <p>The following hint and solution are a working example.</p> Hint (Click if you are stuck) <p>Example for creating an artifact for environment variables:</p> <pre><code>job_name:\n  script:\n  - echo \"foo=bar\" &gt;build.env\n  artifacts:\n    reports:\n      dotenv: build.env\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  variables:\n    BINARY_NAME: hello\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o \"${BINARY_NAME}\" \\\n        .\n  - echo \"${BINARY_NAME}\" &gt;build.env\n  artifacts:\n    paths:\n    - hello\n    reports:\n      dotenv: build.env\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./${BINARY_NAME}\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"065_job_dependencies/exercise/","title":"Job dependencies","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>ignore stages</li> <li>start jobs as soon as dependencies are met</li> </ul>"},{"location":"065_job_dependencies/exercise/#task-start-a-job-early","title":"Task: Start a job early","text":"<p>Start the job <code>build</code> as soon as the job <code>audit</code> completes without waiting for other job of the stage <code>check</code> to finish. Check out the official documentation of <code>needs</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  needs:\n  - audit\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"065_job_dependencies/exercise/#bonus-task-start-a-job-late","title":"Bonus task: Start a job late","text":"<p>If two jobs in the same stage should not be executed at the same time, the <code>needs</code> keyword can also delay a job until the dependencies are met. Modify the job <code>lint</code> so that it waits for the job <code>audit</code> to finish.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  needs:\n  - audit\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  needs:\n  - audit\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"070_schedules/exercise/","title":"Schedules","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>schedule a pipeline run</li> <li>use a schedule to execute a preconfigured pipeline</li> </ul>"},{"location":"070_schedules/exercise/#task-create-a-schedule","title":"Task: Create a schedule","text":"<p>Create a schedule to run a 5 minutes on the branch <code>main</code> in the correct timezone. See the official documentation for schedules.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p>"},{"location":"070_schedules/exercise/#bonus-task-start-a-schedule-manually","title":"Bonus task: Start a schedule manually","text":"<p>Run the previously created schedule manually by clicking the play button . This comes in handy if you need to run a pipeline with pre-configured variables.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p>"},{"location":"090_unit_tests/exercise/","title":"Unit tests","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>execute unit tests</li> <li>publish results in GitLab</li> </ul> <p>This exercise adds a unit test to the hello world application.</p>"},{"location":"090_unit_tests/exercise/#preparation","title":"Preparation","text":"<p>Let's update the code:</p> <pre><code>git checkout upstream/160_gitlab_ci/090_unit_tests -- main_test.go go.mod go.sum\n</code></pre>"},{"location":"090_unit_tests/exercise/#task-publish-unit-test-results","title":"Task: Publish unit test results","text":"<p>The following commands execute unit tests and automatically convert the results to JUnit using gotestsum:</p> <pre><code>go install gotest.tools/gotestsum@latest\ngotestsum --junitfile report.xml\n</code></pre> <p>See the official documentation for special artifacts and specifically reports.</p> <p>Add a job <code>unit_test</code> to the stage <code>check</code> containing the above commands. The job needs to define a special artifact from the file <code>report.xml</code> so that GitLab recognizes it as as JUnit XML report.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run which shows the unit test results on the tab in the overview.</p> Hint (Click if you are stuck) <p>GitLab has published an example. The unit test report is published using a special type of artifact:</p> <pre><code>build:\n  stage: test\n  script: echo\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/090_unit_tests -- '*'\n</code></pre>"},{"location":"100_environments/exercise/","title":"Environments","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>use environments to specify deployment targets</li> <li>select environments dynamically</li> </ul>"},{"location":"100_environments/exercise/#preparation","title":"Preparation","text":"<p>Create CI variables for use in the following exercises:</p> <ol> <li>Create two environments called <code>dev</code> and <code>live</code> in the GitLab UI. No other settings are required</li> <li>Retrieve passwords for dev and live environments from the info page</li> <li>Create unprotected but masked CI variable <code>PASS</code> twice with scope <code>dev</code> and <code>live</code></li> <li>Create unprotected CI variable <code>SEAT_INDEX</code> with your seat number</li> </ol>"},{"location":"100_environments/exercise/#task-1-add-target-environment","title":"Task 1: Add target environment","text":"<p>Add a new stage <code>deploy</code> with a job called <code>deploy</code>. Use the following commands and add an environment to the job in order to upload the binary to the dev environment:</p> <pre><code>curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n    --fail \\\n    --verbose \\\n    --upload-file hello \\\n    --user seat${SEAT_INDEX}:${PASS}\n</code></pre> <p>Mind that <code>curl</code> is not available in the default image <code>golang:1.24.3</code>. You can use <code>curlimages/curl:8.13.0</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to download the <code>hello</code> binary from <code>https://seatN.dev.webdav.inmylab.de/hello</code>.</p> Hint (Click if you are stuck) <p>Install <code>curl</code> in a <code>before_script</code> to separate the preparation from the core steps:</p> <pre><code>job_name:\n  image: curlimages/curl:8.13.0\n</code></pre> <p>Now place the <code>curl</code> command under <code>script</code>.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/100_environments/demo1 -- '*'\n</code></pre>"},{"location":"100_environments/exercise/#task-2-add-deployment-to-development-environment","title":"Task 2: Add deployment to development environment","text":"<p>Create a new branch <code>dev</code> from the branch <code>main</code> and modify the job <code>deploy</code> to use the environment from the pre-defined variable <code>$CI_COMMIT_REF_NAME</code>. Mind that the upload URL is also using a hard-coded environment name.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <pre><code>stages:\n- check\n- build\n- test\n- deploy\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/100_environments/demo2 -- '*'\n</code></pre> <p>This was just a demonstration. The changes will not be preseved in the following chapters.</p>"},{"location":"100_environments/exercise/#task-3-add-deployment-to-production-environment","title":"Task 3: Add deployment to production environment","text":"<p>Create the branch <code>live</code> from the branch <code>dev</code> and push it without further changes.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to download the <code>hello</code> binary from <code>https://seatN.live.inmylab.de/hello</code>.</p> <p>Heads up</p> <p>Checkout the branch <code>main</code> to make sure that the following exercises are based on the correct code base.</p>"},{"location":"110_triggers/exercise/","title":"Triggers","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>trigger pipelines in other projects</li> <li>learn about upstream and downstream pipelines</li> <li>use trigger tokens</li> <li>use multi-project pipelines</li> <li>use parent-child pipelines</li> </ul> <p>Heads up</p> <p>Checkout the branch <code>main</code> to make sure that the following exercises are based on the correct code base.</p>"},{"location":"110_triggers/exercise/#preparation","title":"Preparation","text":"<p>Triggering another pipeline requires a seconds project:</p> <ol> <li>Create a new project, e.g. a private project called <code>trigger</code></li> <li>Add <code>.gitlab-ci.yml</code> with the following content to the root of new project:     <pre><code>test:\n  script:\n  - printenv\n</code></pre></li> </ol>"},{"location":"110_triggers/exercise/#task-1-using-a-trigger-token","title":"Task 1: Using a trigger token","text":"<p>The trigger token allows pipelines to be triggered using the API. Let's give this a try!</p> <p>In the web UI:</p> <ol> <li>In the second project, go to Settings &gt; CI/CD and unfold Pipeline trigger tokens</li> <li>Create a trigger token and copy the token as well as the <code>curl</code> snippet</li> <li>Go back to <code>demo</code> project</li> <li>Create an unprotected but masked CI variable called <code>TOKEN</code></li> </ol> <p>In your pipeline:</p> <ol> <li>Add new stage <code>trigger</code> as well as a job <code>trigger</code></li> <li>Add <code>curl</code> snippet in <code>script</code> block</li> <li>Replace <code>TOKEN</code> with the variable <code>$TOKEN</code></li> <li>Replace <code>REF_NAME</code> with branch name (<code>main</code>)</li> </ol> <p>Afterwards check the pipeline in both projects in the GitLab UI. You should see successful pipeline runs.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://${CI_COMMIT_REF_NAME}.seat${SEAT_INDEX}.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\ntrigger:\n  stage: trigger\n  script: |\n    curl https://gitlab.inmylab.de/api/v4/projects/seat${SEAT_INDEX}%2ftrigger/trigger/pipeline \\\n        --request POST \\\n        --silent \\\n        --fail \\\n        -F \"token=${TOKEN}\" \\\n        -F \"ref=main\"\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/110_triggers/curl -- '*'\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"110_triggers/exercise/#task-2-using-a-multi-project-pipeline","title":"Task 2: Using a multi-project pipeline","text":"<p>The second option for triggering a pipeline in another project, are multi-project pipelines. They come with a handy syntax in <code>gitlab-ci.yaml</code> by using the <code>trigger</code> keyword.</p> <p>Update the job called <code>trigger</code> from the previous task by replacing the <code>script</code> and using the <code>trigger</code> keyword. The value of the <code>trigger</code> keyword should be the path to the project you want to trigger.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to expand the downstream pipeline to see the jobs and their status.</p> Hint (Click if you are stuck) <p>Replace the <code>script</code> keyword with the <code>trigger</code> keyword.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://${CI_COMMIT_REF_NAME}.seat${SEAT_INDEX}.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger: &lt;path-to-project&gt;\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"110_triggers/exercise/#task-3-using-a-parent-child-pipeline","title":"Task 3: Using a parent-child pipeline","text":"<p>A parent-child pipeline executes a downstream pipeline from a YAML file. Modify the contents of the <code>trigger</code> keyword to use <code>include</code> to execute a pipeline with the same content as in the first task but - this time - from a local file <code>child.yaml</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run and be able to expand the downstream pipeline to see the jobs and their status.</p> Hint (Click if you are stuck) <p>Create the file <code>child.yaml</code> with the following pipeline:</p> <pre><code>test:\n  script:\n  - printenv\n</code></pre> <p>Use <code>trigger</code> &gt; <code>include</code> to call the pipeline from this file.</p> Solution (Click if you are stuck) <p><code>child.yaml</code>:</p> <pre><code>test:\n  script:\n  - printenv\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://${CI_COMMIT_REF_NAME}.seat${SEAT_INDEX}.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/110_triggers/parent-child -- '*'\n</code></pre>"},{"location":"120_templates/exercise/","title":"Templates","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>create templates</li> <li>make jobs reusable</li> <li>load templates from different locations</li> </ul>"},{"location":"120_templates/exercise/#task-1-create-a-template-inline","title":"Task 1: Create a template inline","text":"<p>Create a template for compiling a go binary from the job <code>build</code> and use it in the job <code>build</code>. See the official documentation for templates for guidance.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>.build-go:\n  script:\n  #...\n\nbuild:\n  extends: #...\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\n.build-go:\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>You decide whether <code>artifacts</code> is part of the template or not!</p> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/120_templates/inline -- '*'\n</code></pre>"},{"location":"120_templates/exercise/#task-2-loading-templates-from-a-local-file","title":"Task 2: Loading templates from a local file","text":"<p>Move the template into a separate file <code>go.yaml</code> and use the <code>include</code> keyword to import the template.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Create the file <code>go.yaml</code> and move the template there. Use the <code>include</code> keyword to import the template.</p> Solution (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.build-go:\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello \\\n        .\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>include:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/120_templates/local -- '*'\n</code></pre>"},{"location":"120_templates/exercise/#task-3-loading-templates-from-another-project","title":"Task 3: Loading templates from another project","text":"<p>Create a new project anywhere (!), move <code>go.yaml</code> there and fix the <code>include</code> keyword. See the extended syntax of the <code>include</code> keyword to import templates from another project.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>include:\n- project: seatN/template-go\n  ref: main\n  file: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml --format testname\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"130_rules/exercise/","title":"Rules","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>define when to run jobs (and when not)</li> <li>how (workflow) rules can apply to whole pipelines</li> <li>how to use GitLab Pages to publish static web pages</li> </ul> <p>In this exercise we will publish a static web page to download the <code>hello</code> binary.</p>"},{"location":"130_rules/exercise/#preparation","title":"Preparation","text":"<p>Add a file <code>public/index.html</code> to your project using the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/130_rules -- 'public/index.html'\n</code></pre>"},{"location":"130_rules/exercise/#task-1-prevent-a-job-from-running","title":"Task 1: Prevent a job from running","text":"<p>Add a job <code>pages</code> to the stage <code>deploy</code> with the following content:</p> <pre><code>pages:\n  stage: deploy\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n</code></pre> <p>Review the official documentation for the <code>rules</code> keyword and the predefined variables to limit the job <code>pages</code> to run when...</p> <ul> <li>the pipeline was triggered by a push event AND</li> <li>the change applied to the default branch</li> </ul> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint 1 (Click if you are stuck) <p>In pre-defined variables see <code>$CI_PIPELINE_SOURCE</code> for trigger events, <code>$CI_COMMIT_REF_NAME</code> for the current Git reference and <code>$CI_DEFAULT_BRANCH</code> for the default branch.</p> Hint 2 (Click if you are stuck) <p>See complex rules for combining conditions using and (<code>&amp;&amp;</code>) and or (<code>||</code>).</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>include:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  image: alpine\n  script:\n  - cp hello public\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/130_templates -- '*'\n</code></pre>"},{"location":"130_rules/exercise/#task-2-prevent-a-pipeline-from-running","title":"Task 2: Prevent a pipeline from running","text":"<p>Rules can also be placed under the global <code>workflow</code> keyword to apply to the whole pipeline instead of individual jobs.</p> <p>Allow the pipeline to run for the triggers <code>push</code>, <code>web</code>, <code>schedule</code> and <code>pipeline</code> and prevent the pipeline for triggers <code>api</code> and <code>trigger</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>The syntax of <code>workflow</code> looks like this:</p> <pre><code>workflow:\n  rules:\n  #...\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  image: alpine\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/130_rules_workflow -- '*'\n</code></pre>"},{"location":"130_rules/exercise/#task-3-use-deploy-freeze","title":"Task 3: Use deploy freeze","text":"<p>Projects can define a deploy freeze to prevent pipelines to run but the settings only results in an environment variable <code>$CI_DEPLOY_FREEZE</code>. Rules as well as workflow rules can be used to enforce deploy freezes.</p> <p>Modify the pipeline to prevent the execution when <code>$CI_DEPLOY_FREEZE</code> is not empty.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint 1 (Click if you are stuck) <p>Simply enter the variable into a rule to check if it is not empty.</p> Hint 2 (Click if you are stuck) <p>Checkout the <code>when</code> keyword under <code>if</code> to control whether to start a pipeline/job or not.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  environment:\n    name: dev\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.dev.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  image: alpine\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  trigger:\n    include: child.yaml\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"140_merge_requests/exercise/","title":"Merge requests","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>run pipelines in the context of a merge request using rules</li> <li>use template to avoid repetition when using rules</li> </ul>"},{"location":"140_merge_requests/exercise/#task-1-use-rules-to-run-in-merge-request-context","title":"Task 1: Use rules to run in merge request context","text":"<p>In the last chapter about <code>rules</code>, you learned how to use <code>$CI_PIPELINE_SOURCE</code> to restrict execution to specific events. You will need this now.</p> <p>On the branch <code>main</code>, add rules to the jobs to specify when to run them:</p> <ol> <li>Add rules the jobs <code>lint</code>, <code>audit</code>, <code>unit_tests</code>, <code>build</code> and <code>test</code> so that they are executed when...<ol> <li>pushing to the default branch</li> <li>running in merge request context</li> </ol> </li> <li>Run the job <code>trigger</code> only when pushing to the default branch</li> <li>Run the job <code>deploy</code> only when on the branches <code>dev</code> and <code>live</code></li> <li>Do not modify the existing rules for the job <code>pages</code></li> </ol> <p>Also add the merge request event to the workflow rules to allow the pipeline to run in merge request context.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p><code>$CI_PIPELINE_SOURCE</code> can take the values <code>push</code> and <code>merge_request_event</code> in this context. <code>$CI_COMMIT_REF_NAME</code> contains the name of the Git reference (e.g. branch) the pipeline is running on. <code>$CI_DEFAULT_BRANCH</code> contains the name of the default branch of the repository in the current project. You can use the logical operator <code>&amp;&amp;</code> to combine multiple conditions.</p> Solution (Click if you are stuck) <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  extends:\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: $CI_COMMIT_REF_NAME == \"dev\"\n  - if: $CI_COMMIT_REF_NAME == \"live\"\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  image: alpine\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/140_merge_requests -- '*'\n</code></pre>"},{"location":"140_merge_requests/exercise/#task-2-create-a-merge-request","title":"Task 2: Create a merge request","text":"<p>Now we want to check which jobs are executed in the context of a merge request:</p> <ol> <li>Create a new branch based on <code>main</code></li> <li>Push a change to the new branch, e.g. small change to the <code>README.md</code> file</li> <li>Create a merge request into <code>main</code></li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p>"},{"location":"140_merge_requests/exercise/#bonus-task-explore-additional-predefined-variables","title":"Bonus task: Explore additional predefined variables","text":"<p>On the branch of the merge request, add a job and run <code>printenv</code> to get a list of variables available to the pipeline. Check out additional variables specific to merge request pipelines. See also the official documentation.</p>"},{"location":"140_merge_requests/exercise/#task-3-avoid-repetition-using-rule-templates","title":"Task 3: Avoid repetition using rule templates","text":"<p>In the first task we have implemented the same set of rules for multiple jobs. By combining rules with templates, this repetition can be avoided.</p> <ol> <li>Create an inline template called <code>.run-on-push-to-default</code> with the corresponding rule(s)</li> <li>Create a second inline template called <code>.run-on-push-and-mr</code> with the corresponding rule(s)</li> <li>Modify the jobs to use the rule templates</li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Use <code>extends</code> to use the rule template in a job.</p> <p>Remember that only <code>variables</code> are kumulative. All other keywords overwrite each other in the order of appearance.</p> Solution (Click if you are stuck) <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n  artifacts:\n    paths:\n    - hello\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  image: alpine\n  script:\n  - ./hello\n\ndeploy:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello public/\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/140_merge_requests_rule_templates -- '*'\n</code></pre>"},{"location":"150_matrix_jobs/exercise/","title":"Matrix Jobs","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>run the same <code>script</code> for different inputs</li> </ul>"},{"location":"150_matrix_jobs/exercise/#preparation","title":"Preparation","text":"<p>Switch back to the branch <code>main</code>.</p>"},{"location":"150_matrix_jobs/exercise/#task-1-build-binary-for-multiple-platforms","title":"Task 1: Build binary for multiple platforms","text":"<p>Build the <code>hello</code> binary for multiple target platform. Matrix jobs enable you to reuse the existing code and parameterize it using different inputs.</p> <p>Improve the template <code>.build-go</code> in <code>go.yaml</code> to build for <code>linux/amd64</code> and <code>linux/arm64</code>:</p> <ol> <li>Check the official documentation for <code>parallel</code> to create a matrix job</li> <li>Add one input for <code>GOOS=linux</code> and <code>GOARCH=amd64</code></li> <li>Add another input for <code>GOOS=linux</code> and <code>GOARCH=arm64</code></li> <li>Modify the build command to write to separate files using <code>hello-${GOOS}-${GOARCH}</code></li> <li>Move the artifact definition into the template and include all <code>hello</code> binaries</li> <li>Fix the smoke test to execute the <code>hello</code> binary for <code>linux/amd64</code></li> <li>Fix the job <code>deploy</code> to upload the <code>hello</code> binary for <code>linux/amd64</code></li> <li>Fix the job <code>pages</code> to copy the <code>hello</code> binary for <code>linux/amd64</code></li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Matrix pipelines require the <code>parallel:matrix</code> keyword.</p> Solution (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.build-go:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello-${GOOS}-${GOARCH} \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  image: alpine\n  script:\n  - ./hello-linux-amd64\n\ndeploy:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/150_matrix_jobs_demo1 -- '*'\n</code></pre>"},{"location":"150_matrix_jobs/exercise/#task-2-test-an-alternative-to-specify-the-same-inputs","title":"Task 2: Test an alternative to specify the same inputs","text":"<p>Test whether the following syntax for the inputs produces the same results in a pipeline:</p> <pre><code>.build-go:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: [ amd64, arm64 ]\n</code></pre>"},{"location":"150_matrix_jobs/exercise/#bonus-task-check-binaries-for-correct-platform","title":"Bonus task: Check binaries for correct platform","text":"<p>Add another matrix job to check the target platform of the <code>hello</code> binaries:</p> <ol> <li>Add another template called <code>.test-go</code> to <code>go.yaml</code> defining a matrix job using the same inputs as for <code>.build-go</code></li> <li>In the new template run <code>file hello-${GOOS}-${GOARCH}</code> to display the target platform</li> <li>Modify the job <code>test</code> to use the new template</li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.build-go:\n  extends:\n  - .go-targets\n  script:\n  - |\n    go build \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        -o hello-${GOOS}-${GOARCH} \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\n.test-go:\n  extends:\n  - .go-targets\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/150_matrix_jobs_demo2 -- '*'\n</code></pre>"},{"location":"220_services/exercise/","title":"Services","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>define a service</li> <li>access the service</li> </ul>"},{"location":"220_services/exercise/#task-1-create-and-use-a-service","title":"Task 1: Create and use a service","text":"<p>Service are launched in parallel to the regular job to add missing functionality, e.g. a database backend to execute integration tests. See the official documentation and modify the pipeline:</p> <ol> <li>Create service for the whole pipeline based on the container image <code>nginx:1.27.5</code></li> <li>Add a new job <code>test-service</code> to the stage <code>test</code> with the following code:     <pre><code>curl -s http://nginx\n</code></pre></li> <li>Make sure the new job only executes when pushing to <code>main</code></li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>The service is defined globally in the <code>gitlab-ci.yml</code> using the keyword <code>services</code>:</p> <pre><code>services:\n- nginx:1.27.5\n</code></pre> Solution (Click if you are stuck) <p><code>gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nservices:\n- nginx:1.27.5\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ntest-service:\n  stage: test\n  extends:\n  - .run-on-push-to-default-branch\n  script:\n  - curl -s http://nginx\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/220_services -- '*'\n</code></pre>"},{"location":"220_services/exercise/#task-2-move-the-service-into-the-job","title":"Task 2: Move the service into the job","text":"<p>The above task forced a second container to be created for every job although only one job has used the service. Optimize resource usage by moving the service into the job <code>test-service</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ntest-service:\n  stage: test\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - nginx:1.27.5\n  script:\n  - curl -s http://nginx\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"230_docker/exercise/","title":"Docker","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>build a container image...</li> <li>...using a service</li> </ul>"},{"location":"230_docker/exercise/#preparation","title":"Preparation","text":"<p>Building a container image requires a <code>Dockerfile</code> which can be fetched with the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/230_docker -- Dockerfile\n</code></pre>"},{"location":"230_docker/exercise/#task-build-a-container-image","title":"Task: Build a container image","text":"<p>For building a container image, you will need to...</p> <ol> <li>Add a new stage <code>package</code> to the pipeline</li> <li>Add a new job <code>package</code> to the pipeline</li> <li>Use the image <code>docker:28.1.1</code> for the job</li> <li>Add a rule to limit execution to pushes to the default branch</li> <li>Add a service to the job using the image <code>docker:28.1.1-dind</code></li> <li>Add a variable <code>DOCKER_TLS_CERTDIR</code> to the job and set it to an empty string</li> <li>Execute the command <code>docker build --tag hello .</code></li> </ol> <p>Heads-Up</p> <p>The GitLab runner must be configured to run services in privileged mode so that the Docker daemon is able to start.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>The service should be set to:</p> <pre><code>variables:\n  DOCKER_TLS_CERTDIR: \"\"\nservices:\n- name: docker:28.1.1-dind\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- package\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\npackage:\n  image: docker:28.1.1\n  stage: package\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  variables:\n    DOCKER_TLS_CERTDIR: \"\"\n  services:\n  - docker:28.1.1-dind\n  script:\n  - docker build --tag hello .\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/230_docker -- '*'\n</code></pre>"},{"location":"230_docker/exercise/#bonus-task-create-a-template-for-building-container-images","title":"Bonus task: Create a template for building container images","text":"<p>Similar to the template for building and testing Go, create a template for building container images including logging in and out of a container registry.</p>"},{"location":"240_registries/exercise/","title":"Registries","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>authenticate to the GitLab container registry</li> <li>push a container image to the registry</li> </ul>"},{"location":"240_registries/exercise/#task-push-a-container-image","title":"Task: Push a container image","text":"<p>GitLab include a container registry. In this task you will push a container image to the registry. If the container registry is enabled, GitLab automatically provides predefined variables to access and authenticate to the registry:</p> <ul> <li><code>$CI_REGISTRY</code>: The registry URL</li> <li><code>$CI_REGISTRY_IMAGE</code>: The registry URL with the project name</li> <li><code>$CI_REGISTRY_USER</code>: The username to use to push</li> <li><code>$CI_REGISTRY_PASSWORD</code>: The password to use to push</li> </ul> <p>Modify the job <code>package</code>:</p> <ol> <li>Update the build command to use the variables above: <code>docker build --tag \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\" .</code></li> <li>Add the push command directly after the build command: <code>docker push \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\"</code></li> <li>Login to the registry before building: <code>docker login -u \"${CI_REGISTRY_USER}\" -p \"${CI_REGISTRY_PASSWORD}\" \"${CI_REGISTRY}\"</code></li> <li>Logout from the registry after pushing: <code>docker logout \"${CI_REGISTRY}\"</code></li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run. Check the web UI under Deploy -&gt; Container Registry.</p> Hint (Click if you are stuck) <p>Use <code>before_script</code> for logging in and <code>after_script</code> after logging out.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- package\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: alpine\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  before_script:\n  - docker login -u \"${CI_REGISTRY_USER}\" -p \"${CI_REGISTRY_PASSWORD}\" \"${CI_REGISTRY}\"\n  script:\n  - docker build --tag \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\" .\n  - docker push \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\"\n  after_script:\n  - docker logout \"${CI_REGISTRY}\"\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/240_registries -- '*'\n</code></pre>"},{"location":"250_releases/exercise/","title":"Releases","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>create a release on GitLab</li> <li>use the GitLab <code>release-cli</code></li> </ul>"},{"location":"250_releases/exercise/#task-create-a-release","title":"Task: Create a release","text":"<p>GitLab can create releases based on a Git tag. The release can contain a description and links to assets. The assets must be stored elsewhere.</p> <ol> <li>Check out the official documentation about the <code>release</code> keyword</li> <li>Modify the job <code>pages</code> to create a release in addition to the script block</li> <li>The release should be based on the current commit hash (<code>$CI_COMMIT_SHA</code>)</li> <li>Use the unique pipeline ID (<code>$CI_PIPELINE_IID</code>) as the tag name</li> <li>Set an arbitrary name and description</li> </ol> <p>For the <code>release</code> keyword to work, the <code>release-cli</code> binary must be present in the execution environment of the job:</p> <ol> <li>Set <code>image</code> to <code>registry.gitlab.com/gitlab-org/release-cli:v0.23.0</code></li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>Your release should look similar to this:</p> <pre><code>release:\n  tag_name: ${CI_PIPELINE_IID}\n  name: Release ${CI_PIPELINE_IID}\n  description: |\n    Some multi\n    line text\n  ref: ${CI_COMMIT_SHA}\n</code></pre> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- package\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: registry.gitlab.com/gitlab-org/release-cli:v0.23.0\n  release:\n    tag_name: ${CI_PIPELINE_IID}\n    name: Release ${CI_PIPELINE_IID}\n    description: |\n      Some multi\n      line text\n    ref: ${CI_COMMIT_SHA}\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  before_script:\n  - docker login -u \"${CI_REGISTRY_USER}\" -p \"${CI_REGISTRY_PASSWORD}\" \"${CI_REGISTRY}\"\n  script:\n  - docker build --tag \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\" .\n  - docker push \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\"\n  after_script:\n  - docker logout \"${CI_REGISTRY}\"\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/250_releases -- '*'\n</code></pre>"},{"location":"255_troubleshooting/exercise/","title":"Troubleshooting","text":"<p>Goal</p> <p>Learn how to run a pipeline locally</p>"},{"location":"255_troubleshooting/exercise/#preparation","title":"Preparation","text":"<p>Open a terminal and make sure the working directory is your repository.</p>"},{"location":"255_troubleshooting/exercise/#task-1-run-a-single-job","title":"Task 1: Run a single job","text":"<p>Select a single job to run:</p> <pre><code>gcil\n</code></pre>"},{"location":"255_troubleshooting/exercise/#task-2-run-the-whole-pipeline","title":"Task 2: Run the whole pipeline","text":"<p>Run the whole pipeline:</p> <pre><code>gcil --pipeline\n</code></pre>"},{"location":"255_troubleshooting/exercise/#task-3-explore-pre-defined-variables","title":"Task 3: Explore pre-defined variables","text":"<p>Add a job to print all environment variables.</p> Hint (Click if you are stuck) <p>Use the following command to show all environment variables: <code>printenv | sort</code></p> Solution (Click if you are stuck) <pre><code>#...\nnew_job:\nstage: check\nscript: |\n    printenv | sort\n#...\n</code></pre>"},{"location":"255_troubleshooting/exercise/#task-4-pass-variables-to-the-pipeline","title":"Task 4: Pass variables to the pipeline","text":"<p>Check the help how to pass a variable called <code>AUTHOR</code> with a value of your choice.</p> Hint (Click if you are stuck) <p>The parameter <code>-e</code> is used to pass variables to the pipeline.</p> Solution (Click if you are stuck) <pre><code>gcil --pipeline --pipeline -e FOO=bar\n</code></pre>"},{"location":"265_caches/exercise/","title":"Caches","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>define caches</li> <li>store data in a cache</li> <li>restore data from a cache</li> <li>avoid relying on the cache</li> </ul>"},{"location":"265_caches/exercise/#task-1-test-caching","title":"Task 1: Test caching","text":"<p>The cache is used by adding the keyword <code>cache</code> in a pipeline job, a job template or in the <code>default</code> section. Let's give it a try:</p> <ol> <li>Add a job <code>test_cache</code> to the first stage</li> <li>Download dependency information from the uniget project:     <pre><code>curl -sSLfO https://github.com/uniget-org/cli/raw/main/go.mod\ncurl -sSLfO https://github.com/uniget-org/cli/raw/main/go.sum\n</code></pre></li> <li>Use the official example for Go to enable caching</li> <li>Instead of <code>go test</code> run <code>go mod download</code> to download dependencies only</li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run. Retry the job to see the effect of the cache.</p> Hint (Click if you are stuck) <p>Use the <code>.go-cache</code> job template from the official example for Go.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci-yml</code>:</p> <pre><code>#...\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\ntest_cache:\n  stage: check\n  extends:\n  - .go-cache\n  script:\n  - go mod download  \n\n#...\n</code></pre> <p>This was just a demonstration. The changes will not be preserved in the following chapters.</p>"},{"location":"265_caches/exercise/#task-2-add-caching","title":"Task 2: Add caching","text":"<p>Now, integrate the job template <code>.go-cache</code> into the pipeline and use it for the jobs <code>build</code> and <code>unit_test</code>.</p> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>go.yaml</code>:</p> <pre><code>.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\n.build-go:\n  extends:\n  - .go-targets\n  - .go-cache\n  script:\n  - |\n    go build \\\n        -o hello-${GOOS}-${GOARCH} \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\n.test-go:\n  extends:\n  - .go-targets\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/265_caches -- '*'\n</code></pre>"},{"location":"270_renovate/exercise/","title":"Renovate","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>discover dependencies used in your code and pipeline</li> <li>get update proposals for outdated dependencies</li> </ul> <p>We will be using Renovate to discover and update dependencies.</p>"},{"location":"270_renovate/exercise/#task-add-renovate-to-your-pipeline","title":"Task: Add Renovate to your pipeline","text":"<p>The easiest way to get Renovate on GitLab is to integrated it into your pipeline:</p> <ol> <li>Create a new project access token <code>renovate</code> with role <code>Developer</code> and scopes <code>api</code>, <code>read_repository</code>, <code>read_registry</code></li> <li>Add project access token <code>renovate</code> to CI variable <code>RENOVATE_TOKEN</code></li> <li>Add a job <code>renovate</code> to the stage <code>check</code></li> <li>Limit execution to a) scheduled pipelines and b) if the variable <code>$RENOVATE</code> is set</li> <li>Use the image <code>renovate/renovate</code></li> <li>Set the variable <code>LOG_LEVEL</code> to <code>debug</code></li> <li>Use the following script to execute Renovate:     <pre><code>renovate --platform gitlab \\\n    --endpoint ${CI_API_V4_URL} \\\n    --token ${RENOVATE_TOKEN} \\\n    ${CI_PROJECT_PATH}\n</code></pre></li> <li>Create a scheduled pipeline and define a variable <code>RENOVATE</code> with the value <code>true</code></li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- package\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nrenovate:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"schedule\" &amp;&amp; $RENOVATE'\n  image: renovate/renovate\n  variables:\n    LOG_LEVEL: debug\n  script: |\n    renovate --platform gitlab \\\n        --endpoint ${CI_API_V4_URL} \\\n        --token ${CI_JOB_TOKEN} \\\n        --autodiscover true\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: registry.gitlab.com/gitlab-org/release-cli:v0.23.0\n  release:\n    tag_name: ${CI_PIPELINE_IID}\n    name: Release ${CI_PIPELINE_IID}\n    description: |\n      Some multi\n      line text\n    ref: ${CI_COMMIT_SHA}\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  before_script:\n  - docker login -u \"${CI_REGISTRY_USER}\" -p \"${CI_REGISTRY_PASSWORD}\" \"${CI_REGISTRY}\"\n  script:\n  - docker build --tag \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\" .\n  - docker push \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\"\n  after_script:\n  - docker logout \"${CI_REGISTRY}\"\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/270_renovate -- '*'\n</code></pre>"},{"location":"280_security/exercise/","title":"Security","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>detect secrets in your code</li> <li>detect vulnerabilities in your code</li> </ul>"},{"location":"280_security/exercise/#task-add-integrated-security-scans","title":"Task: Add integrated security scans","text":"<p>GitLab offers multiple security scanners in the community edition:</p> <ol> <li>Checkout the official documentation for secret detection and integrate it into your pipeline</li> <li>Checkout the official documentation for static application security testing and integrate it into your pipeline</li> <li>Checkout the official documentation for container scanning and integrate it into your pipeline</li> </ol> <p>Afterwards check the pipeline in the GitLab UI. You should see a successful pipeline run.</p> Hint (Click if you are stuck) <p>The following templates are available for the above features:</p> <ul> <li>Secret detection: <code>Security/Secret-Detection.gitlab-ci.yml</code></li> <li>Static application security testing: <code>Security/SAST.gitlab-ci.yml</code></li> <li>Container scanning: <code>Security/Container-Scanning.gitlab-ci.yml</code></li> </ul> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>workflow:\n  rules:\n  - if: $CI_DEPLOY_FREEZE\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'push'\n  - if: $CI_PIPELINE_SOURCE == 'web'\n  - if: $CI_PIPELINE_SOURCE == 'schedule'\n  - if: $CI_PIPELINE_SOURCE == 'pipeline'\n  - if: $CI_PIPELINE_SOURCE == 'api'\n    when: never\n  - if: $CI_PIPELINE_SOURCE == 'trigger'\n    when: never\n\ninclude:\n- local: go.yaml\n- template: Security/Secret-Detection.gitlab-ci.yml\n- template: Security/SAST.gitlab-ci.yml\n- template: Security/Container-Scanning.gitlab-ci.yml\n\ncontainer_scanning:\n  stage: trigger\n  variables:\n    CS_DEFAULT_BRANCH_IMAGE: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\n    CI_APPLICATION_REPOSITORY: ${CI_REGISTRY_IMAGE}\n    CI_APPLICATION_TAG: ${CI_COMMIT_REF_NAME}\n\n.run-on-push-to-default-branch:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n\n.run-on-push-and-in-mr:\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n\nstages:\n- check\n- build\n- test\n- deploy\n- package\n- trigger\n\ndefault:\n  image: golang:1.24.3\n\nrenovate:\n  stage: check\n  rules:\n  - if: '$CI_PIPELINE_SOURCE == \"schedule\" &amp;&amp; $RENOVATE'\n  image: renovate/renovate\n  variables:\n    LOG_LEVEL: debug\n  script: |\n    renovate --platform gitlab \\\n        --endpoint ${CI_API_V4_URL} \\\n        --token ${RENOVATE_TOKEN} \\\n        --autodiscover true\n\nlint:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go fmt .\n\naudit:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go vet .\n\nunit_tests:\n  stage: check\n  extends:\n  - .run-on-push-and-in-mr\n  script:\n  - go install gotest.tools/gotestsum@latest\n  - gotestsum --junitfile report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\nbuild:\n  stage: build\n  extends:\n  - .run-on-push-and-in-mr\n  - .build-go\n\ntest:\n  stage: test\n  extends:\n  - .run-on-push-and-in-mr\n  - .test-go\n\ndeploy:\n  stage: deploy\n  rules:\n  - if: '$CI_COMMIT_REF_NAME == \"dev\" || $CI_COMMIT_REF_NAME == \"live\"'\n  environment:\n    name: ${CI_COMMIT_REF_NAME}\n  image: curlimages/curl:8.13.0\n  script:\n  - |\n    curl https://seat${SEAT_INDEX}.${CI_COMMIT_REF_NAME}.webdav.inmylab.de/ \\\n        --fail \\\n        --verbose \\\n        --upload-file hello-linux-amd64 \\\n        --user seat${SEAT_INDEX}:${PASS}\n\npages:\n  stage: deploy\n  extends:\n  - .run-on-push-to-default-branch\n  image: registry.gitlab.com/gitlab-org/release-cli:v0.23.0\n  release:\n    tag_name: ${CI_PIPELINE_IID}\n    name: Release ${CI_PIPELINE_IID}\n    description: |\n      Some multi\n      line text\n    ref: ${CI_COMMIT_SHA}\n  script:\n  - cp hello-linux-amd64 public/hello\n  artifacts:\n    paths:\n    - public\n\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  before_script:\n  - docker login -u \"${CI_REGISTRY_USER}\" -p \"${CI_REGISTRY_PASSWORD}\" \"${CI_REGISTRY}\"\n  script:\n  - docker build --tag \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\" .\n  - docker push \"${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\"\n  after_script:\n  - docker logout \"${CI_REGISTRY}\"\n\ntrigger:\n  stage: trigger\n  extends:\n  - .run-on-push-to-default-branch\n  trigger:\n    include: child.yaml\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/280_security -- '*'\n</code></pre> <p>Heads-Up</p> <p>You can also select a different scanner for container scanning using the variable <code>$CS_ANALYZER_IMAGE</code>. The following values are available:</p> Scanner Image Default (trivy) registry.gitlab.com/security-products/container-scanning:6 Grype registry.gitlab.com/security-products/container-scanning/grype:6 Trivy registry.gitlab.com/security-products/container-scanning/trivy:6"},{"location":"300_components/exercise/","title":"CI/CD Components","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>Create a component</li> <li>Add inputs to a component</li> <li>Use a component locally</li> </ul> <p>Hints</p> <p>Official documentation for CI/CD Components</p>"},{"location":"300_components/exercise/#task-1-create-a-component","title":"Task 1: Create a component","text":"<p>Create a component in the same repository:</p> <ol> <li>Add a new directory called <code>templates</code></li> <li>Add a new file called <code>templates/go.yml</code></li> <li>Add <code>spec</code> in the header</li> <li>Add inputs called <code>build-stage</code> and <code>test-stage</code></li> </ol> Hint (Click if you are stuck) <ul> <li>The file must have the extension <code>.yml</code> not <code>.yaml</code></li> <li>The file must be located in the directory <code>templates</code></li> <li>The header and body of a component must be separated by a line containing only <code>---</code></li> </ul> Solution (Click if you are stuck) <p><code>templates/go.yml</code>:</p> <pre><code>spec:\n  inputs:\n    build-stage:\n      default: build\n    test-stage:\n      default: test\n---\n</code></pre>"},{"location":"300_components/exercise/#task-2-add-inputs-to-the-component","title":"Task 2: Add inputs to the component","text":"<p>Now fill the body of the component with the job templates for Go in <code>go.yaml</code>:</p> <ol> <li>Copy all job templates from <code>go.yaml</code> to the body of <code>templates/go.yml</code></li> <li>Unhide the jobs <code>.build-go</code> and <code>.test-go</code></li> <li>Use the input <code>build-stage</code> for the <code>stage</code> field in the <code>build-go</code> job</li> <li>Use the input <code>test-stage</code> for the <code>stage</code> field in the <code>test-go</code> job</li> <li>Add an <code>image</code> field to <code>build-go</code> and <code>test-go</code> with a value of <code>golang:1.24.3</code></li> <li>Remove <code>go.yaml</code></li> </ol> Hint (Click if you are stuck) <ul> <li>The header and body of a component must be separated by a line containing only <code>---</code></li> <li>Unhide a job by removing the leading dot</li> </ul> Solution (Click if you are stuck) <p><code>templates/go.yml</code>:</p> <pre><code>spec:\n  inputs:\n    build-stage:\n      default: build\n    test-stage:\n      default: test\n---\n\n.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\nbuild-go:\n  stage: $[[ inputs.build-stage ]]\n  image: golang:1.24.3\n  extends:\n  - .go-targets\n  - .go-cache\n  script:\n  - |\n    go build \\\n        -o hello-${GOOS}-${GOARCH} \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\ntest-go:\n  stage: $[[ inputs.test-stage ]]\n  image: golang:1.24.3\n  extends:\n  - .go-targets\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre>"},{"location":"300_components/exercise/#task-3-use-component-locally","title":"Task 3: Use component locally","text":"<p>The component is now ready to be used:</p> <ol> <li>Add an <code>include</code> for the component</li> <li>Set the inputs <code>build-stage</code> and <code>test-stage</code> to <code>build</code> and <code>test</code> respectively</li> <li>Remove the jobs <code>build</code> and <code>test</code> from <code>.gitlab-ci.yml</code></li> </ol> Hint (Click if you are stuck) <ul> <li>Check out the documentation of <code>include</code> for components</li> <li>Unhide a job by removing the leading dot</li> </ul> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\ninclude:\n- component: $CI_SERVER_FQDN/$CI_PROJECT_PATH/go@$CI_COMMIT_SHA\n  inputs:\n    build-stage: build\n    test-stage: test\n#...\n</code></pre>"},{"location":"300_components/exercise/#task-4-add-input-for-image","title":"Task 4: Add input for image","text":"<p>Customize the template to make the image configurable:</p> <ol> <li>Add an input called <code>image</code> to the component</li> <li>Set the default value of <code>image</code> to <code>golang:1.24.3</code></li> <li>Use the input <code>image</code> for the <code>image</code> field in the <code>build-go</code> and <code>test-go</code> jobs</li> <li>(Optionally) Add a value for <code>image</code> to the include in <code>.gitlab-ci.yml</code></li> </ol> Hint (Click if you are stuck) <p>The syntax for using an input in a component is <code>$[[ inputs.&lt;name&gt; ]]</code></p> Solution (Click if you are stuck) <p><code>templates/go.yml</code>:</p> <pre><code>spec:\n  inputs:\n    build-stage:\n      default: build\n    test-stage:\n      default: test\n    image:\n      default: golang:1.24.3\n---\n\n.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\nbuild-go:\n  stage: $[[ inputs.build-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  - .go-cache\n  script:\n  - |\n    go build \\\n        -o hello-${GOOS}-${GOARCH} \\\n        -ldflags \"-X main.Version=${CI_COMMIT_REF_NAME} -X 'main.Author=${AUTHOR}'\" \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\ntest-go:\n  stage: $[[ inputs.test-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\ninclude:\n- component: $CI_SERVER_FQDN/$CI_PROJECT_PATH/go@$CI_COMMIT_SHA\n  inputs:\n    build-stage: build\n    test-stage: test\n    image: golang:1.24.3\n#...\n</code></pre>"},{"location":"300_components/exercise/#task-5-add-input-for-version-and-author","title":"Task 5: Add input for version and author","text":"<p>Continue to customize the component by making the author name as well as the version configurable:</p> <ol> <li>Add an input called <code>author</code> to the component</li> <li>Replace the variable for the author with the input <code>author</code> in the <code>build-go</code> job</li> <li>Add an input called <code>version</code> to the component</li> <li>Replace the variable for the version with the input <code>version</code> in the <code>build-go</code> job</li> </ol> Hint (Click if you are stuck) <p>Replace the variables <code>${AUTHOR}</code> and <code>${VERSION}</code> with the inputs <code>$[[ inputs.author ]]</code> and <code>$[[ inputs.version ]]</code>.</p> Solution (Click if you are stuck) <p><code>templates/go.yml</code>:</p> <pre><code>spec:\n  inputs:\n    build-stage:\n      default: build\n    test-stage:\n      default: test\n    image:\n      default: golang:1.24.3\n    version:\n      default: $CI_COMMIT_REF_NAME\n    author:\n      default: $GITLAB_USER_NAME\n---\n\n.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\nbuild-go:\n  stage: $[[ inputs.build-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  - .go-cache\n  script:\n  - |\n    go build \\\n        -o hello-${GOOS}-${GOARCH} \\\n        -ldflags \"-X main.Version=$[[ inputs.version ]] -X 'main.Author=$[[ inputs.author ]]'\" \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\ntest-go:\n  stage: $[[ inputs.test-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\ninclude:\n- component: $CI_SERVER_FQDN/$CI_PROJECT_PATH/go@$CI_COMMIT_SHA\n  inputs:\n    build-stage: build\n    test-stage: test\n    image: golang:1.24.3\n    author: ${GITLAB_USER_NAME}\n    version: ${CI_COMMIT_REF_NAME}\n#...\n</code></pre>"},{"location":"300_components/exercise/#task-6-name-prefix","title":"Task 6: Name prefix","text":"<p>Components import whole jobs into a pipeline which can cause name conflicts. To avoid this issue, add a prefix to the job names:</p> <ol> <li>Add an input called <code>name-prefix</code> to the component</li> <li>Use the input <code>name-prefix</code> to prefix the job names in the component</li> <li>Add a value for <code>name-prefix</code> to the include in <code>.gitlab-ci.yml</code></li> </ol> Hint (Click if you are stuck) <p>Inputs can be used anywhere - even in job names.</p> Solution (Click if you are stuck) <p><code>templates/go.yml</code>:</p> <pre><code>spec:\n  inputs:\n    name-prefix:\n      default: \"foo\"\n    build-stage:\n      default: build\n    test-stage:\n      default: test\n    image:\n      default: golang:1.24.3\n    version:\n      default: $CI_COMMIT_REF_NAME\n    author:\n      default: $GITLAB_USER_NAME\n---\n\n.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\n$[[ inputs.name-prefix]]-build-go:\n  stage: $[[ inputs.build-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  - .go-cache\n  script:\n  - |\n    go build \\\n        -o hello-${GOOS}-${GOARCH} \\\n        -ldflags \"-X main.Version=$[[ inputs.version ]] -X 'main.Author=$[[ inputs.author ]]'\" \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\n$[[ inputs.name-prefix]]-test-go:\n  stage: $[[ inputs.test-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\ninclude:\n- component: $CI_SERVER_FQDN/$CI_PROJECT_PATH/go@$CI_COMMIT_SHA\n  inputs:\n    build-stage: build\n    test-stage: test\n    image: golang:1.24.3\n    author: ${GITLAB_USER_NAME}\n    version: ${CI_COMMIT_REF_NAME}\n#...\n</code></pre>"},{"location":"300_components/exercise/#task-7-add-array-input-for-rules","title":"Task 7: Add array input for rules","text":"<p>The components has only used string inputs so far. To configure rules for the jobs of a component, an array input is needed:</p> <ol> <li>Add an input called <code>rules</code> to the component</li> <li>Set the type of the new input to <code>array</code></li> <li>Use the input <code>rules</code> for the <code>rules</code> field in the <code>build-go</code> and <code>test-go</code> jobs</li> <li>Add a value for <code>rules</code> in the include and copy the rules from the job template <code>.run-on-push-and-in-mr</code> to </li> </ol> Hint (Click if you are stuck) <p>Input types are documented here.</p> Solution (Click if you are stuck) <p><code>templates/go.yml</code>:</p> <pre><code>spec:\n  inputs:\n    name-prefix:\n      default: \"foo\"\n    build-stage:\n      default: build\n    test-stage:\n      default: test\n    image:\n      default: golang:1.24.3\n    version:\n      default: $CI_COMMIT_REF_NAME\n    author:\n      default: $GITLAB_USER_NAME\n    rules:\n      type: array\n      default: []\n---\n\n.go-targets:\n  parallel:\n    matrix:\n    - GOOS: linux\n      GOARCH: amd64\n    - GOOS: linux\n      GOARCH: arm64\n\n.go-cache:\n  variables:\n    GOPATH: $CI_PROJECT_DIR/.go\n  before_script:\n  - mkdir -p .go\n  cache:\n    key: ${CI_PROJECT_PATH_SLUG}\n    policy: pull-push\n    paths:\n    - .go/pkg/mod/\n\n$[[ inputs.name-prefix]]-build-go:\n  stage: $[[ inputs.build-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  - .go-cache\n  rules: $[[ inputs.rules ]]\n  script:\n  - |\n    go build \\\n        -o hello-${GOOS}-${GOARCH} \\\n        -ldflags \"-X main.Version=$[[ inputs.version ]] -X 'main.Author=$[[ inputs.author ]]'\" \\\n        .\n  artifacts:\n    paths:\n    - hello-${GOOS}-${GOARCH}\n\n$[[ inputs.name-prefix]]-test-go:\n  stage: $[[ inputs.test-stage ]]\n  image: $[[ inputs.image ]]\n  extends:\n  - .go-targets\n  rules: $[[ inputs.rules ]]\n  before_script:\n  - apt-get update\n  - apt-get -y install file\n  script:\n  - |\n    file hello-${GOOS}-${GOARCH}\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\ninclude:\n- component: $CI_SERVER_FQDN/$CI_PROJECT_PATH/go@$CI_COMMIT_SHA\n  inputs:\n    build-stage: build\n    test-stage: test\n    image: golang:1.24.3\n    author: ${GITLAB_USER_NAME}\n    version: ${CI_COMMIT_REF_NAME}\n    rules:\n    - if: '$CI_PIPELINE_SOURCE == \"push\" &amp;&amp; $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH'\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n#...\n</code></pre> <p>If you want to jump to the solution, execute the following command:</p> <pre><code>git checkout upstream/160_gitlab_ci/300_components -- '*'\n</code></pre>"},{"location":"300_components/exercise/#bonus-task-1-move-the-component-to-a-separate-project","title":"Bonus task 1: Move the component to a separate project","text":"<p>Using a separate project for a component is the prerequisite to use it in the CI/project Catalog:</p> <ol> <li>Create a new project</li> <li>Copy the directory <code>templates</code> to the new project</li> <li>Push the changes to the new project</li> <li>Create a release in the new project</li> </ol> <p>You can also add a <code>.gitlab-ci.yml</code> to the new project to test the component.</p>"},{"location":"300_components/exercise/#bonus-task-2-add-the-component-to-the-cicd-catalog","title":"Bonus task 2: Add the component to the CI/CD Catalog","text":"<p>Toggle the project to be a catalog project.</p>"},{"location":"300_components/exercise/#bonus-task-3-add-inputs-for-goos-and-goarch","title":"Bonus task 3: Add inputs for GOOS and GOARCH","text":"<p>Make the variables <code>GOOS</code> and <code>GOARCH</code> from the job <code>.go-targets</code> configurable by adding an input.</p>"},{"location":"310_steps/exercise/","title":"CI/CD Steps","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>Create a step</li> <li>Add inputs to a step</li> <li>Use a step locally</li> </ul> <p>Hints</p> <p>Official documentation for CI/CD Components</p>"},{"location":"310_steps/exercise/#task-1-create-a-step-for-logging-into-a-container-registry","title":"Task 1: Create a step for logging into a container registry","text":"<p>The step will wrap logging in to a container registry using Docker and enable the reuse across pipelines:</p> <ol> <li>Create a new directory called <code>steps/docker/login</code> with a file called <code>step.yml</code></li> <li>Add a <code>spec</code> header with an <code>inputs</code> section</li> <li>Add an input called <code>registry</code> with a default value of <code>docker.io</code></li> <li>Add an input called <code>username</code> with no default value</li> <li>Add an input called <code>password</code> with no default value</li> <li>Create the step in the body using the <code>exec.command</code> keyword </li> <li>Use the <code>docker login</code> command with the provided inputs</li> </ol> Hint (Click if you are stuck) <ul> <li>Inputs are used with the same syntax as in components: <code>$[[ inputs.&lt;name&gt; ]]</code></li> </ul> Solution (Click if you are stuck) <p><code>go/step.yml</code>:</p> <pre><code>spec:\n  inputs:\n    registry:\n      type: string\n      default: docker.io\n    username:\n      type: string\n    password:\n      type: string\n---\nexec:\n  command: docker login $[[ inputs.registry ]] --username $[[ inputs.username ]] --password $[[ inputs.password ]]\n</code></pre>"},{"location":"310_steps/exercise/#task-2-use-the-step","title":"Task 2: Use the step","text":"<p>The local step can be used in the job <code>package</code> in <code>.gitlab-ci.yml</code> by referencing the directory without <code>step.yml</code>:</p> <ol> <li>Remove the <code>before_script</code>, <code>script</code> and <code>after_script</code> from the job <code>package</code></li> <li>Use the step <code>docker_login</code> in the <code>run</code> section of the job <code>package</code></li> <li>Provide values for <code>registry</code>, <code>username</code> and <code>password</code></li> </ol> Hint (Click if you are stuck) <p>The credentials for the integrated container registry are provided as pre-defined environment variables: - Hostname in <code>${CI_REGISTRY}</code> - Username in <code>${CI_REGISTRY_USER}</code> - Password in <code>${CI_REGISTRY_PASSWORD}</code></p> Solution (Click if you are stuck) <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  run:\n  - name: docker_login\n    step: ./steps/docker/login/step.yml\n    inputs:\n      registry: ${CI_REGISTRY}\n      username: ${CI_REGISTRY_USER}\n      password: ${CI_REGISTRY_PASSWORD}\n#...\n</code></pre>"},{"location":"310_steps/exercise/#task-3-create-a-step-for-building-container-images","title":"Task 3: Create a step for building container images","text":"<p>Create and use a step for Docker build by converting the first command script block of the job <code>package</code> in <code>.gitlab-ci.yml</code>. The step should have two inputs called <code>context</code> and <code>image</code>.</p> Hint (Click if you are stuck) <ul> <li>The name for a container image matching the current project is supplied in a pre-defined environment variable called <code>${CI_REGISTRY_IMAGE}</code></li> </ul> Solution (Click if you are stuck) <p><code>steps/docker/build/step.yml</code>:</p> <pre><code>spec:\ninputs:\n    context:\n    type: string\n    default: .\n    image:\n    type: string\n---\nexec:\ncommand: docker build --tag \"$[[ inputs.image ]]\" $[[ inputs.context ]]\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  run:\n  - name: docker_login\n    step: ./steps/docker/login/step.yml\n    inputs:\n      registry: ${CI_REGISTRY}\n      username: ${CI_REGISTRY_USER}\n      password: ${CI_REGISTRY_PASSWORD}\n  - name: docker_build\n    step: ./steps/docker/build/step.yml\n    inputs:\n      context: .\n      image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\n#...\n</code></pre>"},{"location":"310_steps/exercise/#task-4-create-a-step-for-pushing-container-images","title":"Task 4: Create a step for pushing container images","text":"<p>Create and use a step for Docker build by converting the first command script block of the job <code>package</code> in <code>.gitlab-ci.yml</code>. The step should have one input called <code>image</code>.</p> Hint (Click if you are stuck) <p>Make sure the image name is the same as in the build step.</p> Solution (Click if you are stuck) <p><code>steps/docker/push/step.yml</code>:</p> <pre><code>spec:\ninputs:\n    context:\n    type: string\n    default: .\n    image:\n    type: string\n---\nexec:\ncommand: docker push \"$[[ inputs.image ]]\"\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  run:\n  - name: docker_login\n    step: ./steps/docker/login/step.yml\n    inputs:\n      registry: ${CI_REGISTRY}\n      username: ${CI_REGISTRY_USER}\n      password: ${CI_REGISTRY_PASSWORD}\n  - name: docker_build\n    step: ./steps/docker/build/step.yml\n    inputs:\n      context: .\n      image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\n  - name: docker_push\n    step: ./steps/docker/push/step.yml\n    inputs:\n      image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\n#...\n</code></pre>"},{"location":"310_steps/exercise/#task-5-create-a-step-for-logging-out-of-a-container-registry","title":"Task 5: Create a step for logging out of a container registry","text":"<p>Create and use a step for Docker build by converting the first command script block of the job <code>package</code> in <code>.gitlab-ci.yml</code>. The step should have one input called <code>registry</code>.</p> Hint (Click if you are stuck) <p>The hostname of the integrated container registry is supplied in a pre-defined environment variable called <code>${CI_REGISTRY}</code></p> Solution (Click if you are stuck) <p><code>steps/docker/logout/step.yml</code>:</p> <pre><code>spec:\ninputs:\n    registry:\n    type: string\n    default: docker.io\n---\nexec:\ncommand: docker logout $[[ inputs.registry ]]\n</code></pre> <p><code>.gitlab-ci.yml</code>:</p> <pre><code>#...\npackage:\n  image: docker:28.1.1\n  stage: package\n  extends:\n  - .run-on-push-to-default-branch\n  services:\n  - name: docker:28.1.1-dind\n    command: [ \"dockerd\", \"--host\", \"tcp://0.0.0.0:2375\" ]\n  variables:\n    DOCKER_HOST: tcp://docker:2375\n  run:\n  - name: docker_login\n    step: ./steps/docker/login/step.yml\n    inputs:\n      registry: ${CI_REGISTRY}\n      username: ${CI_REGISTRY_USER}\n      password: ${CI_REGISTRY_PASSWORD}\n  - name: docker_build\n    step: ./steps/docker/build/step.yml\n    inputs:\n      context: .\n      image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\n  - name: docker_push\n    step: ./steps/docker/push/step.yml\n    inputs:\n      image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}\n  - name: docker_logout\n    step: ./steps/docker/logout/step.yml\n    inputs:\n      registry: ${CI_REGISTRY}\n#...\n</code></pre>"},{"location":"310_steps/exercise/#bonus-task-move-the-step-to-a-separate-project","title":"Bonus task: Move the step to a separate project","text":"<p>Move the steps into a separate project and use them from there. Check out the official documentation how to use steps from a git repository.</p> Hint 1 (Click if you are stuck) <p>Use a proper name for the project like <code>steps/docker</code> or <code>docker-steps</code> in an arbitraty namespace.</p> Hint 2 (Click if you are stuck) <p>Use the following directory structure to host all steps in the same project:</p> <pre><code>login/\n  step.yml\nbuild/\n  step.yml\npush/\n  step.yml\nlogout/\n  step.yml\n</code></pre> Hint 3 (Click if you are stuck) <p>Use variables to reference the steps in the job:</p> <pre><code>my_job:\n  run:\n  - name: docker_login:\n    step:\n      git:\n        url: ${CI_SERVER_HOST}/library/steps/docker\n        dir: login\n        rev: main\n  #...\n</code></pre>"},{"location":"330_secure_files/exercise/","title":"Secure Files","text":"<p>Goal</p> <p>Learn how to...</p> <ul> <li>Upload secure files</li> <li>Use secure files in a job</li> </ul> <p>Hints</p> <p>Official documentation for Secure Files</p>"},{"location":"330_secure_files/exercise/#task-1-upload-a-secure-file","title":"Task 1: Upload a secure file","text":"<p>Upload an arbitraty file as a secure file.</p> <p>!! tip \"Data protection\"     Do not use sensitive information.</p> Hint (Click if you are stuck) <p>Take a closer look at the documentation for secure files</p> Solution (Click if you are stuck) <p>Go to Settings &gt; CI/CD &gt; Secure Files and upload one or more files</p>"},{"location":"330_secure_files/exercise/#task-2-use-the-secure-file","title":"Task 2: Use the secure file","text":"<p>Use the previously uploaded secure file in a job.</p> Hint 1 (Click if you are stuck) <p>Take a closer look at the documentation for secure files</p> Hint 2 (Click if you are stuck) <p>See the sample in the repository for <code>download-secure-files</code></p> Hint 3 (Click if you are stuck) <p>See the sample repository</p>"}]}